#!/usr/bin/env node

/*!
 * bmocha - alternative mocha implementation
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bmocha
 */

'use strict';

const assert = require('assert');
const fs = require('fs');
const os = require('os');
const path = require('path');
const glob = require('../vendor/glob.js');
const bmocha = require('../lib/bmocha.js');
const {isImport} = require('../lib/esm.js');
const imports = require('../lib/imports.js');

const {
  basename,
  dirname,
  extname,
  isAbsolute,
  join,
  normalize,
  relative,
  resolve
} = path;

const {
  Array,
  Boolean,
  Error,
  Object,
  process,
  RegExp
} = global;

const {
  errorify,
  Mocha,
  style
} = bmocha;

const cwd = process.cwd();
const {argv, env, stdin, stdout, stderr, exit} = process;
const on = process.on.bind(process);
const off = process.removeListener.bind(process);

/*
 * Constants
 */

const VERSION = '2.2.0';

const HELP = `
  Usage: bmocha [options] [files]
         bmocha debug [options] [files]
         bmocha init <path> [options] [files]

  Commands:

    debug                    start bmocha with the node.js debugger enabled
    init <path>              initialize a client-side bmocha setup at <path>

  Options:

    --allow-uncaught         enable uncaught errors to propagate
                             (default: false)
    -A, --async-only         require all tests to use a callback or promise
                             (default: false)
    -B, --backend <value>    set the NODE_BACKEND environment variable
    -b, --bail               bail after first test failure (default: false)
    --check-leaks            check for global variable leaks (default: false)
    --chrome <path>          chrome binary to use for headless mode
    -c, --colors             force enabling of colors
    -C, --no-colors          force disabling of colors
    --conditions <string>    use custom conditional exports conditions
    --config <path>          path to config file (default: nearest rc file)
    --csp-source <src>       add content-security-policy source
                             (default: 'self')
    --delay                  delay initial execution of root suite
                             (default: false)
    --diff                   show diff on failure (default: true)
    --dry-run                report tests without executing them
    -e, --env <name=val>     set environment variable (can be specified multiple
                             times)
    --exclude <file>         a file to ignore
    --exit                   force shutdown of the event loop after test run
                             (default: false)
    --extension <ext>        file extension(s) to load and/or watch
                             (default: js, cjs, mjs)
    --fail-zero              fail test run if no tests encountered
    -f, --fgrep <string>     only run tests containing <string>
    --file <file>            include a file to be ran during the suite
    --firefox                use firefox instead of chrome for headless mode
    --forbid-only            fail if exclusive test(s) encountered
                             (default: false)
    --forbid-pending         fail if pending test(s) encountered
                             (default: false)
    --full-trace             display full stack traces (default: false)
    -g, --grep <pattern>     only run tests matching <pattern>
    -G, --growl              enable growl notifications (default: false)
    --globals <names>        allow the given comma-delimited global <names>
    -H, --headless           run tests in headless chrome (default: false)
    -h, --help               output usage information
    -i, --invert             inverts --grep and --fgrep matches (default: false)
    --inline-diffs           display actual/expected differences inline (noop)
                             (default: false)
    -j, --jobs <number>      number of concurrent jobs for --parallel
                             (default: number of CPU cores minus 1)
    --list-interfaces        display available interfaces
    --list-reporters         display available reporters
    -l, --listen             serve client-side test files (requires browserify)
                             (default: false)
    -m, --cmd <cmd>          set browser command (default: $BROWSER)
    --node <path>            path to node.js binary (default: process.execPath)
    -n, --node-option <arg>  node or v8 option (no leading '--')
    -o, --open               open browser after serving (default: false)
    -O, --reporter-options   reporter-specific options
    --opts <path>            path to "mocha.opts" (default: ./test/mocha.opts)
    --package <path>         path to package.json for config
                             (default: ./package.json)
    -p, --parallel           run tests in parallel (noop)
    -P, --port <port>        port to listen on (default: 8080)
    -R, --reporter <name>    specify the reporter to use (default: spec)
    -r, --require <name>     require the given module
    --recursive              include sub directories (default: false)
    --retries <times>        set numbers of time to retry a failed test case
                             (default: 0)
    -s, --slow <ms>          "slow" test threshold in milliseconds (default: 75)
    -S, --sort               sort test files (default: false)
    --ssl                    use ssl to listen (default: false)
    --ssl-cert <path>        path to ssl cert file
    --ssl-ignore             ignore certificate errors (headless mode only)
                             (default: false)
    --ssl-key <path>         path to ssl key file
    --swallow                swallow errors post-completion to mimic mocha
                             (default: true)
    -t, --timeout <ms>       set test-case timeout in milliseconds
                             (default: 2000)
    --timeouts               enables timeouts (default: true)
    -u, --ui <name>          specify user-interface (bdd) (default: bdd)
    --valgrind               run tests with valgrind enabled
    --valgrind-log           run tests with valgrind enabled (write to log file)
    -V, --version            output the version number
    -w, --watch              watch files in the current working directory
                             (default: false)
    --watch-files <file>     list of paths or globs to watch when --watch is set
    --watch-ignore <file>    list of paths or globs to exclude from watching.
                             (default: node_modules and .git)
    --why                    display why node continues to run after the suite
                             has ended (similar to why-is-node-running)
    -z, --console            use console in browser (default: false)

  Environment Variables:

    BMOCHA_OPTIONS           space-separated list of command-line options
`;

const INTERFACES = `
    bdd
`;

const REPORTERS = `
    doc - html documentation
    dot - dot matrix
    json - single json object
    json-stream - newline delimited json events
    landing - unicode landing strip
    list - spec-style listing
    markdown - markdown documentation (github flavour)
    min - minimal reporter (great with --watch)
    nyan - nyan cat!
    progress - progress bar
    spec - hierarchical spec list
    tap - test-anything-protocol
    xunit - xunit reporter
`;

const DEFAULT_BOPTS = resolve(cwd, 'test', 'bmocha.opts');
const DEFAULT_OPTS = resolve(cwd, 'test', 'mocha.opts');
const DEFAULT_PKG = resolve(cwd, 'package.json');
const BIN_PATH = resolve(__dirname, '..', 'bin');
const LIB_PATH = resolve(__dirname, '..', 'lib');
const IN_MOCHA = basename(cwd) === 'bmocha';

/*
 * Helpers
 */

function string(str) {
  assert(typeof str === 'string');
  return JSON.stringify(str);
}

function wrapImport(file) {
  assert(typeof file === 'string');

  return async () => {
    const path = resolve(cwd, file);

    if (await imports.supported() && isImport(path)) {
      await imports(imports.pathToFileURL(path));
      return;
    }

    delete require.cache[require.resolve(path)];

    require(path);
  };
}

function readdir(path) {
  assert(typeof path === 'string');
  return fs.readdirSync(path).map((name) => {
    return join(path, name);
  });
}

function exists(file) {
  assert(typeof file === 'string');
  try {
    fs.statSync(file);
    return true;
  } catch (e) {
    if (e.code === 'ENOENT')
      return false;
    throw e;
  }
}

function findFile(files) {
  assert(Array.isArray(files));

  for (const file of files) {
    if (exists(file))
      return file;
  }

  return null;
}

function findExt(name, extensions) {
  assert(typeof name === 'string');
  assert(Array.isArray(extensions));

  if (exists(name))
    return name;

  // Historically, mocha only looked
  // for `.js` files. We can do better
  // by checking for all of the user's
  // file extensions.
  for (const ext of extensions) {
    const file = `${name}${ext}`;

    if (exists(file))
      return file;
  }

  return null;
}

function mergeExts(extensions, files) {
  assert(Array.isArray(extensions));
  assert(Array.isArray(files));

  const out = new Set(extensions);

  for (const file of files) {
    const ext = extname(file);

    if (ext.length > 0)
      out.add(ext);
  }

  return [...out];
}

function mkdirp(path, mode) {
  if (mode == null)
    mode = 0o777;

  assert(typeof path === 'string');
  assert((mode >>> 0) === mode);

  const paths = [];

  let dir = normalize(path);

  for (;;) {
    paths.push(dir);

    const next = dirname(dir);

    if (next === dir)
      break;

    dir = next;
  }

  paths.reverse();

  for (const path of paths) {
    if (!exists(path))
      fs.mkdirSync(path, mode);
  }
}

function rimraf(path) {
  if (fs.rmSync) {
    fs.rmSync(path, {
      force: true,
      recursive: true,
      maxRetries: 3
    });
  } else {
    fs.rmdirSync(path, {
      recursive: true,
      maxBusyTries: 3,
      maxRetries: 3
    });
  }
}

function exception(err, code) {
  if (err && err.stack)
    err = err.stack;

  code >>>= 0;

  stderr.write(err + '\n');
  exit(code || 1);
}

function noop() {
  return;
}

/*
 * Test File Traversal
 */

function globify(files) {
  assert(Array.isArray(files));

  const out = [];

  const options = {
    cwd,
    silent: true,
    // Legacy windows behavior.
    windowsPathsNoEscape: true,
    allowWindowsEscape: false
  };

  for (const file of files) {
    if (glob.hasMagic(file, options)) {
      const result = glob.sync(file, options);

      if (result.length === 0)
        throw new Error(`Could not resolve pattern: ${string(file)}.`);

      out.push(...result);

      continue;
    }

    if (!exists(file))
      throw new Error(`File not found: ${string(file)}.`);

    out.push(file);
  }

  return out;
}

function hasExtension(file, extensions) {
  assert(typeof file === 'string');
  assert(Array.isArray(extensions));

  for (const ext of extensions) {
    if (file.endsWith(ext))
      return true;
  }

  return false;
}

function flatten(files, extensions, recurse = false) {
  assert(Array.isArray(files));
  assert(Array.isArray(extensions));
  assert(typeof recurse === 'boolean');

  for (const file of files)
    assert(typeof file === 'string');

  for (const ext of extensions) {
    assert(typeof ext === 'string');
    assert(ext.length > 0 && ext[0] === '.');
  }

  return walk(files, extensions, recurse, 0, []);
}

function walk(files, extensions, recurse, depth, out) {
  for (const file of files) {
    const stat = fs.statSync(file);

    if (stat.isDirectory()) {
      // Avoid symlink loops (diverges from mocha).
      if (fs.lstatSync(file).isSymbolicLink())
        continue;

      // Without the recurse option,
      // mocha delves one level deep.
      if (recurse || depth === 0)
        walk(readdir(file), extensions, recurse, depth + 1, out);

      continue;
    }

    // If a file was given to us explicity,
    // do not filter. The result of a glob is
    // considered explicit (mimic mocha behavior).
    if (depth === 0) {
      if (!stat.isFile()) {
        // Mocha throws with a nasty error
        // in this case. We can do better.
        throw new Error(`Not a regular file: ${string(file)}.`);
      }
      out.push(file);
      continue;
    }

    // Files only.
    if (!stat.isFile())
      continue;

    // No dotfiles.
    if (basename(file)[0] === '.')
      continue;

    // Only our specific extensions.
    if (extensions.length > 0) {
      if (!hasExtension(file, extensions))
        continue;
    }

    out.push(file);
  }

  return out;
}

function exclude(files, excludes) {
  assert(Array.isArray(files));
  assert(Array.isArray(excludes));

  if (excludes.length === 0)
    return files;

  const options = {
    // Legacy windows behavior.
    windowsPathsNoEscape: true,
    allowWindowsEscape: false
  };

  excludes = excludes.map((pattern) => {
    if (isAbsolute(pattern))
      pattern = relative(cwd, pattern);

    pattern = normalize(pattern);

    if (glob.hasMagic(pattern, options))
      return pattern;

    let stat = null;

    try {
      stat = fs.statSync(pattern);
    } catch (e) {
      if (e.code === 'ENOENT')
        return pattern;
      throw e;
    }

    if (stat.isDirectory()) {
      if (pattern[pattern.length - 1] === path.sep)
        pattern = pattern.slice(0, -1);

      return `${pattern}/**`;
    }

    return pattern;
  });

  excludes = excludes.map((pattern) => {
    return new glob.Minimatch(pattern, options);
  });

  return files.filter((name) => {
    if (isAbsolute(name))
      name = relative(cwd, name);

    name = normalize(name);

    return excludes.every((pattern) => {
      return !pattern.match(name);
    });
  });
}

function resolvify(files) {
  assert(Array.isArray(files));
  return files.map(file => resolve(cwd, file));
}

/*
 * Watching Helpers
 */

function getFiles(root, extensions, out = []) {
  assert(typeof root === 'string');
  assert(Array.isArray(extensions));
  assert(Array.isArray(out));

  for (const name of fs.readdirSync(root)) {
    if (name === '.git' || name === 'node_modules')
      continue;

    const file = join(root, name);
    const stat = fs.lstatSync(file);

    if (stat.isDirectory()) {
      getFiles(file, extensions, out);
      continue;
    }

    // Files only.
    if (!stat.isFile())
      continue;

    // Only our specific extensions.
    if (extensions.length > 0) {
      if (!hasExtension(name, extensions))
        continue;
    }

    // Ignore everything in
    // our own bin and lib.
    if (IN_MOCHA) {
      if (file.startsWith(BIN_PATH) ||
          file.startsWith(LIB_PATH)) {
        continue;
      }
    }

    out.push(file);
  }

  return out;
}

function watchFiles(files, callback) {
  assert(Array.isArray(files));
  assert(typeof callback === 'function');

  const options = { interval: 100 };

  const cb = async (current, previous) => {
    const prev = previous.mtime.getTime();
    const cur = current.mtime.getTime();

    if (prev >= cur)
      return;

    try {
      await callback();
    } catch (e) {
      exception(e);
    }
  };

  for (const file of files)
    fs.watchFile(file, options, cb);
}

/*
 * Process Helpers
 */

function spawn(file, args, shell = false) {
  const cp = require('child_process');

  const ps = cp.spawn(file, args, {
    cwd,
    env,
    detached: true,
    stdio: 'ignore',
    shell
  });

  ps.on('error', noop);

  ps.unref();

  return ps;
}

function navigate(url, cmd) {
  assert(typeof url === 'string');
  assert(cmd == null || typeof cmd === 'string');

  // Any OS:
  if (cmd) {
    if (cmd.includes('%s')) {
      cmd = cmd.replace(/%s/g, url);
      return spawn(cmd, [], true);
    }

    return spawn(cmd, [url], true);
  }

  // Windows:
  // https://stackoverflow.com/questions/3739327
  if (process.platform === 'win32')
    return spawn('explorer', [url]);

  // OSX:
  // https://superuser.com/questions/85151
  if (process.platform === 'darwin')
    return spawn('open', [url]);

  // Unix:
  const name = env.BROWSER;

  if (!name)
    return spawn('xdg-open', [url]);

  if (/(?:chrome|chromium)/i.test(name))
    return spawn(name, [`--app=${url}`]);

  return spawn(name, [url]);
}

function findChrome() {
  // See: https://github.com/karma-runner/karma-chrome-launcher
  if (process.platform === 'darwin') {
    return findFile([
      '/Applications/Chromium.app/Contents/MacOS/Chromium',
      '/Applications/Google Chrome.app/Contents/MacOS/Google Chrome'
    ]);
  }

  if (process.platform === 'win32') {
    // https://stackoverflow.com/questions/40674914
    const names = [
      '\\Chromium\\Application\\chromium.exe',
      '\\Chromium\\chromium.exe',
      '\\Google\\Chrome\\Application\\chrome.exe', // Windows 10
      '\\Google\\Application\\chrome.exe', // Windows 7
      '\\Google\\Chrome\\chrome.exe' // Windows XP/Vista
    ];

    const files = [];

    for (const name of names) {
      for (const dir of [env.LOCALAPPDATA,
                         env.PROGRAMFILES,
                         env['PROGRAMFILES(X86)'],
                         env.ProgramW6432]) {
        if (!dir || dir.length === 0)
          continue;

        files.push(join(dir, name));
      }
    }

    return findFile(files);
  }

  if (!env.PATH)
    return null;

  const files = [];

  for (const name of ['chromium-browser',
                      'chromium',
                      'google-chrome',
                      'google-chrome-stable']) {
    for (const dir of env.PATH.split(':')) {
      if (dir.length === 0)
        continue;

      files.push(join(dir, name));
    }
  }

  return findFile(files);
}

function findFirefox() {
  // See: https://github.com/karma-runner/karma-firefox-launcher
  if (process.platform === 'darwin') {
    return findFile([
      '/Applications/Firefox.app/Contents/MacOS/firefox'
    ]);
  }

  if (process.platform === 'win32') {
    const names = [
      '\\Mozilla Firefox\\firefox.exe'
    ];

    const files = [];

    for (const name of names) {
      for (const dir of [env.LOCALAPPDATA,
                         env.PROGRAMFILES,
                         env['PROGRAMFILES(X86)'],
                         env.ProgramW6432]) {
        if (!dir || dir.length === 0)
          continue;

        files.push(join(dir, name));
      }
    }

    return findFile(files);
  }

  if (!env.PATH)
    return null;

  const files = [];

  for (const name of ['firefox']) {
    for (const dir of env.PATH.split(':')) {
      if (dir.length === 0)
        continue;

      files.push(join(dir, name));
    }
  }

  return findFile(files);
}

function bindExit(handler) {
  assert(typeof handler === 'function');

  let unbind;

  const handle = (code) => {
    unbind();
    handler(code);
  };

  const c = os.constants.signals || {};
  const onExit = () => handle(null);
  const onSighup = () => handle(c.SIGHUP | 0x80);
  const onSigint = () => handle(c.SIGINT | 0x80);
  const onSigterm = () => handle(c.SIGTERM | 0x80);

  const onError = (err) => {
    unbind();

    if (err && err.stack)
      err = err.stack;

    stderr.write(err + '\n');
    handler(1);
  };

  unbind = () => {
    process.removeListener('exit', onExit);
    process.removeListener('SIGHUP', onSighup);
    process.removeListener('SIGINT', onSigint);
    process.removeListener('SIGTERM', onSigterm);
    process.removeListener('uncaughtException', onError);
    process.removeListener('unhandledRejection', onError);
    process.on('SIGINT', noop);
  };

  process.once('exit', onExit);

  if (process.listenerCount('SIGHUP') === 0)
    process.once('SIGHUP', onSighup);

  if (process.listenerCount('SIGINT') === 0)
    process.once('SIGINT', onSigint);

  if (process.listenerCount('SIGTERM') === 0)
    process.once('SIGTERM', onSigterm);

  if (process.listenerCount('uncaughtException') === 0)
    process.once('uncaughtException', onError);

  if (process.listenerCount('unhandledRejection') === 0)
    process.once('unhandledRejection', onError);

  process.on('newListener', (name) => {
    switch (name) {
      case 'SIGHUP':
        process.removeListener(name, onSighup);
        break;
      case 'SIGINT':
        process.removeListener(name, onSigint);
        break;
      case 'SIGTERM':
        process.removeListener(name, onSigterm);
        break;
      case 'uncaughtException':
        process.removeListener(name, onError);
        break;
      case 'unhandledRejection':
        process.removeListener(name, onError);
        break;
    }
  });

  return unbind;
}

function runHeadless(url, options) {
  assert(typeof url === 'string');
  assert(options && typeof options === 'object');

  const cp = require('child_process');

  let tmpDir;

  do {
    const id = (Math.random() * 0x100000000) >>> 0;
    tmpDir = join(os.tmpdir(), `bmocha-${id}`);
  } while (exists(tmpDir));

  mkdirp(tmpDir, 0o755);

  let file, args;

  if (options.firefox) {
    file = options.chrome || findFirefox();

    if (!file)
      throw new Error('Could not find firefox binary.');

    // https://github.com/karma-runner/karma-firefox-launcher
    const prefs = [
      ['browser.shell.checkDefaultBrowser', false],
      ['browser.bookmarks.restore_default_bookmarks', false],
      ['dom.disable_open_during_load', false],
      ['dom.max_script_run_time', 0],
      ['dom.min_background_timeout_value', 10],
      ['extensions.autoDisableScopes', 0],
      ['browser.tabs.remote.autostart', false],
      ['browser.tabs.remote.autostart.2', false],
      ['extensions.enabledScopes', 15]
    ];

    if (options.sslIgnore)
      prefs.push(['network.stricttransportsecurity.preloadlist', false]);

    const lines = prefs.map(([key, val]) => {
      return `user_pref("${key}", ${JSON.stringify(val)});`;
    });

    fs.writeFileSync(join(tmpDir, 'prefs.js'), lines.join('\n'));

    args = [
      '-headless',
      '-profile', tmpDir,
      '-no-remote'
    ];
  } else {
    file = options.chrome || findChrome();

    if (!file)
      throw new Error('Could not find chrome binary.');

    // https://github.com/karma-runner/karma-chrome-launcher
    // https://github.com/GoogleChrome/chrome-launcher/blob/main/docs/chrome-flags-for-tools.md
    args = [
      '--user-data-dir=' + tmpDir,
      '--headless',
      '--disable-gpu',
      '--disable-dev-shm-usage',
      '--remote-debugging-port=0',
      '--no-default-browser-check',
      '--no-first-run',
      '--disable-default-apps',
      '--disable-extensions',
      '--disable-popup-blocking',
      '--disable-translate',
      '--disable-background-timer-throttling'
    ];

    if (/chrome/i.test(basename(file))) {
      args.push(
        '--enable-automation',
        '--disable-renderer-backgrounding',
        '--disable-device-discovery-notifications'
      );
    }

    if (env.CI)
      args.push('--no-sandbox');

    if (options.sslIgnore)
      args.push('--ignore-certificate-errors');
  }

  args.push(url);

  let output = '';
  let unbind = noop;

  const cleanup = () => {
    try {
      rimraf(tmpDir);
    } catch (e) {
      stderr.write(e.stack + '\n');
    }
  };

  const onData = (data) => {
    if (output.length > (1 << 20))
      output = '';
    output += data;
  };

  const onError = (err) => {
    if (err.code === 'ENOENT')
      exception(`Chrome not found: ${string(err.path)}.`);
    else
      exception(err);
  };

  const onExit = (code, signal) => {
    code >>>= 0;

    unbind();
    cleanup();

    stderr.write('Chrome exited unexpectedly ');
    stderr.write(`(code=${code}, signal=${signal}).\n`);

    if (output.length > 0) {
      stderr.write('\n');
      stderr.write(output);
      stderr.write('\n');
    }

    if (code === 0)
      code = 1;

    exit(code);
  };

  const ps = cp.spawn(file, args, {
    cwd,
    env,
    detached: false,
    stdio: ['ignore', 'pipe', 'pipe'],
    shell: false
  });

  ps.stdout.setEncoding('utf8');
  ps.stdout.on('error', noop);
  ps.stdout.on('data', onData);

  ps.stderr.setEncoding('utf8');
  ps.stderr.on('error', noop);
  ps.stderr.on('data', onData);

  ps.on('error', onError);
  ps.on('exit', onExit);

  const close = (cb) => {
    let timeout = setTimeout(() => {
      timeout = null;
      ps.kill('SIGKILL');
    }, 2500);

    ps.removeListener('error', onError);
    ps.removeListener('exit', onExit);
    ps.on('error', noop);

    ps.on('exit', () => {
      if (timeout != null)
        clearTimeout(timeout);
      cleanup();
      cb();
    });

    ps.kill('SIGTERM');
  };

  unbind = bindExit((code) => {
    if (code == null) {
      // Should never happen.
      ps.removeListener('error', onError);
      ps.removeListener('exit', onExit);
      ps.on('error', noop);
      ps.kill('SIGKILL');
      cleanup();
    } else {
      close(() => exit(code));
    }
  });

  return () => {
    return new Promise((resolve, reject) => {
      try {
        unbind();
        close(resolve);
      } catch (e) {
        reject(e);
      }
    });
  };
}

/*
 * Config Parsing
 */

function findConfig(root) {
  assert(typeof root === 'string');

  let dir = normalize(root);

  for (;;) {
    for (const name of ['.bmocharc.js',
                        '.bmocharc.mjs',
                        '.bmocharc.json',
                        '.mocharc.js',
                        '.mocharc.mjs',
                        '.mocharc.yaml',
                        '.mocharc.yml',
                        '.mocharc.jsonc',
                        '.mocharc.json']) {
      const file = join(dir, name);

      if (exists(file))
        return file;
    }

    const next = dirname(dir);

    if (next === dir)
      break;

    dir = next;
  }

  return null;
}

function parseConfig(json) {
  assert(json && typeof json === 'object');

  const args = [];

  for (const key of Object.keys(json)) {
    const value = json[key];

    switch (typeof value) {
      case 'boolean': {
        args.push(value ? `--${key}` : `--no-${key}`);
        break;
      }

      case 'number':
      case 'string': {
        args.push(`--${key}`);
        args.push(String(value));
        break;
      }

      case 'object': {
        if (Array.isArray(value)) {
          const arg = [];

          args.push(`--${key}`);

          for (const item of value)
            arg.push(String(item));

          args.push(arg.join(','));
        } else if (value instanceof RegExp) {
          args.push(value.source);
        } else if (value != null) {
          const arg = [];

          args.push(`--${key}`);

          for (const k of Object.keys(value))
            arg.push(`${k}=${value[k]}`);

          args.push(arg.join(','));
        }

        break;
      }
    }
  }

  return args;
}

async function readJS(file) {
  assert(typeof file === 'string');

  const path = resolve(cwd, file);

  if (await imports.supported() && isImport(path)) {
    const ns = await imports(imports.pathToFileURL(path));
    return ns['default'] || ns;
  }

  return require(path);
}

function readJSON(file) {
  assert(typeof file === 'string');
  const text = fs.readFileSync(file, 'utf8');
  return JSON.parse(text);
}

/*
 * Argument Parsing
 */

function normalizeArgs(argv) {
  assert(Array.isArray(argv));

  const args = [];

  for (let i = 0; i < argv.length; i++) {
    const arg = argv[i];

    assert(typeof arg === 'string');

    if (arg.startsWith('--')) {
      // e.g. --opt
      const index = arg.indexOf('=');
      if (index !== -1) {
        // e.g. --opt=val
        args.push(arg.substring(0, index));
        args.push(arg.substring(index + 1));
      } else {
        args.push(arg);
      }
    } else if (arg.startsWith('-')) {
      if (arg.length > 2) {
        // e.g. -abc
        for (let j = 1; j < arg.length; j++)
          args.push(`-${arg.charAt(j)}`);
      } else {
        // e.g. -a
        args.push(arg);
      }
    } else {
      // e.g. foo
      args.push(arg);
    }
  }

  return args;
}

async function getArgs(argv) {
  assert(Array.isArray(argv));

  const args = [];
  const out = [];

  // Parse BMOCHA_OPTIONS environment variable.
  if (env.BMOCHA_OPTIONS) {
    const text = env.BMOCHA_OPTIONS;
    const parts = text.replace(/\\\s/g, '%20')
                      .split(/\s+/);
    const items = [];

    for (const arg of parts) {
      if (arg.length === 0)
        continue;

      if (arg === '--')
        throw new Error(`Invalid argument: ${arg}.`);

      items.push(arg.replace(/%20/g, ' '));
    }

    args.push(...normalizeArgs(items));
  }

  // Normalize process arg vector.
  args.push(...normalizeArgs(argv));

  // Quickly parse through args
  // to find config files.
  let config = null;
  let opts = null;
  let pkg = null;

  for (let i = 0; i < args.length; i++) {
    switch (args[i]) {
      case '-h':
      case '--help':
      case '--list-interfaces':
      case '--list-reporters':
      case '-V':
      case '--version':
        return [0, args];
      case '--':
        i = args.length;
        break;
      case '--config': {
        if (i + 1 < args.length)
          config = args[++i];
        break;
      }
      case '--no-config': {
        config = false;
        break;
      }
      case '--opts': {
        if (i + 1 < args.length)
          opts = args[++i];
        break;
      }
      case '--no-opts': {
        opts = false;
        break;
      }
      case '--package': {
        if (i + 1 < args.length)
          pkg = args[++i];
        break;
      }
      case '--no-package': {
        pkg = false;
        break;
      }
    }
  }

  // Parse main config (rc) file.
  if (config === null)
    config = findConfig(cwd);

  if (typeof config === 'string') {
    const ext = extname(config);

    let json = null;

    switch (ext) {
      case '.js':
      case '.mjs':
        json = await readJS(config);
        break;
      case '.json':
        json = readJSON(config);
        break;
      default:
        stderr.write('Warning: ');
        stderr.write(`cannot read ${ext} config: `);
        stderr.write(`${string(config)}.\n`);
        break;
    }

    if (json && typeof json === 'object') {
      out.push(...parseConfig(json));

      if (pkg === null && json.package !== undefined)
        pkg = json.package;

      if (opts === null && json.opts !== undefined)
        opts = json.opts;
    }
  }

  // Parse package.json "mocha" field.
  if (pkg === null && exists(DEFAULT_PKG))
    pkg = DEFAULT_PKG;

  if (typeof pkg === 'string') {
    const data = readJSON(pkg);

    if (!data || typeof data !== 'object')
      throw new Error(`Invalid package.json: ${string(pkg)}.`);

    const json = data.bmocha || data.mocha;

    if (json && typeof json === 'object') {
      out.push(...parseConfig(json));

      if (opts === null && json.opts !== undefined)
        opts = json.opts;
    }
  }

  // Parse legacy test/mocha.opts file.
  if (opts === null) {
    if (exists(DEFAULT_BOPTS))
      opts = DEFAULT_BOPTS;
    else if (exists(DEFAULT_OPTS))
      opts = DEFAULT_OPTS;
  }

  if (typeof opts === 'string') {
    const text = fs.readFileSync(opts, 'utf8');
    const parts = text.replace(/^#.*$/gm, '')
                      .replace(/\\\s/g, '%20')
                      .split(/\s+/);
    const items = [];

    for (const arg of parts) {
      if (arg.length === 0)
        continue;

      if (arg === '--')
        throw new Error(`Invalid argument: ${arg}.`);

      items.push(arg.replace(/%20/g, ' '));
    }

    out.push(...normalizeArgs(items));
  }

  // Args go on last (higher precedence).
  return [out.length, out.concat(args)];
}

async function parseArgs() {
  const options = {
    __proto__: null,
    allowUncaught: false,
    asyncOnly: false,
    backend: null,
    bail: false,
    cert: null,
    checkLeaks: false,
    chrome: null,
    cmd: '',
    colors: Boolean(stdout.isTTY),
    conditions: [],
    console: false,
    delay: false,
    diff: true,
    dryRun: false,
    env: Object.create(null),
    excludes: [],
    exit: false,
    extensions: [],
    failZero: false,
    fgrep: '',
    forbidOnly: false,
    forbidPending: false,
    fileArgs: [],
    files: [],
    fullTrace: false,
    firefox: false,
    global: true,
    globals: [],
    grep: null,
    growl: false,
    headless: false,
    implyHeadless: false,
    implyListen: false,
    implyOpen: false,
    implySSL: false,
    init: null,
    invert: false,
    jobs: 1,
    key: null,
    listen: false,
    open: false,
    parallel: false,
    port: -1,
    recurse: false,
    reporter: 'spec',
    reporterOptions: Object.create(null),
    requires: [],
    retries: 0,
    slow: 75,
    sources: [],
    ssl: false,
    sslIgnore: false,
    sort: false,
    stream: stdout,
    swallow: true,
    timeout: 2000,
    timeouts: true,
    watch: false,
    watchFiles: [],
    watchIgnore: ['.git', 'node_modules'],
    why: false,
    windows: process.platform === 'win32'
  };

  let {
    excludes,
    extensions,
    fileArgs,
    files,
    reporterOptions,
    requires,
    watchFiles,
    watchIgnore
  } = options;

  let i = 0;
  let value = true;
  let imply = false;

  const [start, args] = await getArgs(argv.slice(2));

  const ensure = () => {
    if (!value)
      throw new Error(`Invalid argument: ${args[i]}.`);
  };

  const next = () => {
    ensure();

    if (i + 1 >= args.length || args[i + 1].length === 0)
      throw new Error(`Invalid option for ${args[i]}.`);

    return args[++i];
  };

  for (; i < args.length; i++) {
    let arg = args[i];

    value = true;
    imply = false;

    if (arg.startsWith('--no-')) {
      arg = `--${arg.substring(5)}`;
      value = false;
    } else {
      imply = i >= start;
    }

    switch (arg) {
      case '-A':
      case '--async-only': {
        options.asyncOnly = value;
        break;
      }

      case '--allow-uncaught': {
        options.allowUncaught = value;
        break;
      }

      case '-B':
      case '--backend': {
        options.backend = value ? next() : null;
        break;
      }

      case '-b':
      case '--bail': {
        options.bail = value;
        break;
      }

      case '--check-leaks': {
        options.checkLeaks = value;
        break;
      }

      case '--chrome': {
        options.chrome = value ? next() : null;
        break;
      }

      case '-c':
      case '--color':
      case '--colors': {
        options.colors = value;
        break;
      }

      case '-C': {
        options.colors = false;
        break;
      }

      case '--conditions': {
        options.conditions = next().split(',');
        break;
      }

      case '--config': {
        if (value)
          next();
        break;
      }

      case '--csp-source': {
        if (!value) {
          options.sources.length = 0;
          break;
        }

        for (const src of next().split(',')) {
          if (src.length === 0)
            throw new Error('Invalid CSP source.');

          options.sources.push(src);
        }

        break;
      }

      case '--delay': {
        options.delay = value;
        break;
      }

      case '--diff': {
        options.diff = value;
        break;
      }

      case '--dry-run': {
        options.dryRun = value;
        break;
      }

      case '-e':
      case '--env': {
        if (!value) {
          options.env = Object.create(null);
          break;
        }

        const pair = next();

        if (pair.length === 0)
          throw new Error('Invalid environment variable.');

        const index = pair.indexOf('=');

        if (index === -1) {
          options.env[pair] = '1';
          break;
        }

        const key = pair.substring(0, index);
        const val = pair.substring(index + 1);

        if (val.length > 0)
          options.env[key] = val;
        else
          options.env[key] = null;

        break;
      }

      case '--ignore':
      case '--exclude': {
        if (value)
          excludes.push(next());
        else
          excludes.length = 0;

        break;
      }

      case '--exit': {
        options.exit = value;
        break;
      }

      case '--extension': {
        if (!value) {
          extensions.length = 0;
          break;
        }

        for (let ext of next().split(',')) {
          if (ext.length === 0 || ext === '.')
            throw new Error(`Invalid file extension: ${ext}.`);

          if (ext[0] !== '.')
            ext = '.' + ext;

          extensions.push(ext);
        }

        break;
      }

      case '--fail-zero': {
        options.failZero = value;
        break;
      }

      case '-f':
      case '--fgrep': {
        options.fgrep = value ? next() : '';
        break;
      }

      case '--file': {
        if (value)
          fileArgs.push(next());
        else
          fileArgs.length = 0;

        break;
      }

      case '--forbid-only': {
        options.forbidOnly = value;
        break;
      }

      case '--forbid-pending': {
        options.forbidPending = value;
        break;
      }

      case '--full-trace': {
        options.fullTrace = value;
        break;
      }

      case '--firefox': {
        options.firefox = value;
        break;
      }

      case '-g':
      case '--grep': {
        options.grep = value ? new RegExp(next()) : null;
        break;
      }

      case '-G':
      case '--growl': {
        options.growl = value;
        break;
      }

      case '--global':
      case '--globals': {
        if (!value) {
          options.globals.length = 0;
          break;
        }

        const globals = next().split(',');

        if (globals.includes(''))
          throw new Error(`Invalid globals: ${args[i]}.`);

        options.globals = globals;

        break;
      }

      case '-H':
      case '--headless': {
        options.headless = value;
        options.implyListen = imply;
        break;
      }

      case '-h':
      case '--help': {
        ensure();
        stdout.write(HELP + '\n');
        exit(0);
        break;
      }

      case '-i':
      case '--invert': {
        options.invert = value;
        break;
      }

      case '--inline-diffs': {
        break;
      }

      case '-j':
      case '--jobs': {
        if (!value) {
          options.jobs = 1;
          break;
        }

        const jobs = next() | 0;

        if (jobs < 1 || jobs > 20)
          throw new Error(`Invalid jobs: ${jobs}.`);

        options.jobs = jobs;

        break;
      }

      case '--list-interfaces': {
        ensure();
        stdout.write(INTERFACES + '\n');
        exit(0);
        break;
      }

      case '--list-reporters': {
        ensure();
        stdout.write(REPORTERS + '\n');
        exit(0);
        break;
      }

      case '-l':
      case '--listen': {
        options.listen = value;
        break;
      }

      case '-m':
      case '--cmd': {
        options.cmd = value ? next() : '';
        options.implyOpen = imply;
        break;
      }

      case '--node': {
        if (value)
          next();
        break;
      }

      case '-o':
      case '--open': {
        options.open = value;
        options.implyListen = imply;
        break;
      }

      case '-O':
      case '--reporter-option':
      case '--reporter-options': {
        if (!value) {
          reporterOptions = Object.create(null);
          break;
        }

        for (const opt of next().split(',')) {
          const parts = opt.split('=');

          if (parts.length > 2 || parts[0].length === 0)
            throw new Error(`Invalid reporter option: ${opt}.`);

          if (parts.length === 2)
            reporterOptions[parts[0]] = parts[1];
          else
            reporterOptions[parts[0]] = true;
        }

        break;
      }

      case '--opts': {
        if (value)
          next();
        break;
      }

      case '--package': {
        if (value)
          next();
        break;
      }

      case '-p':
      case '--parallel': {
        options.parallel = value;
        break;
      }

      case '-P':
      case '--port': {
        if (!value) {
          options.port = -1;
          options.implyListen = imply;
          break;
        }

        const port = next() | 0;

        if (port < 0 || port > 0xffff)
          throw new Error(`Invalid port: ${port}.`);

        options.port = port;
        options.implyListen = imply;

        break;
      }

      case '-R':
      case '--reporter': {
        options.reporter = value ? next() : 'spec';
        break;
      }

      case '-r':
      case '--require': {
        if (value)
          requires.push(next());
        else
          requires.length = 0;

        break;
      }

      case '--recursive': {
        options.recurse = value;
        break;
      }

      case '--retries': {
        options.retries = value ? next() >>> 0 : 0;
        break;
      }

      case '-s':
      case '--slow': {
        options.slow = value ? next() >>> 0 : 75;
        break;
      }

      case '-S':
      case '--sort': {
        options.sort = value;
        break;
      }

      case '--ssl': {
        options.ssl = value;
        options.implyListen = imply;
        break;
      }

      case '--cert':
      case '--ssl-cert': {
        options.cert = value ? fs.readFileSync(next()) : null;
        options.implySSL = imply;
        break;
      }

      case '--ssl-ignore': {
        options.sslIgnore = value;
        options.implySSL = imply;
        break;
      }

      case '--key':
      case '--ssl-key': {
        options.key = value ? fs.readFileSync(next()) : null;
        options.implySSL = imply;
        break;
      }

      case '--swallow': {
        options.swallow = value;
        break;
      }

      case '-t':
      case '--timeout': {
        options.timeout = value ? next() >>> 0 : 0;
        break;
      }

      case '--timeouts': {
        options.timeouts = value;
        break;
      }

      case '-u':
      case '--ui': {
        const ui = value ? next() : 'bdd';

        if (ui !== 'bdd')
          throw new Error(`Invalid interface: ${ui}.`);

        break;
      }

      case '-V':
      case '--version': {
        ensure();
        stdout.write(VERSION + '\n');
        exit(0);
        break;
      }

      case '-w':
      case '--watch': {
        options.watch = value;
        break;
      }

      case '--watch-files': {
        if (!value) {
          watchFiles.length = 0;
          break;
        }

        for (const file of next().split(','))
          watchFiles.push(file);

        break;
      }

      case '--watch-ignore': {
        if (!value) {
          watchIgnore.length = 0;
          break;
        }

        for (const file of next().split(','))
          watchIgnore.push(file);

        break;
      }

      case '--why': {
        options.why = value;
        break;
      }

      case '-z':
      case '--console': {
        options.console = value;
        options.implyListen = imply;
        break;
      }

      case '--': {
        i = args.length;
        break;
      }

      default: {
        if (arg.length === 0 || arg[0] === '-')
          throw new Error(`Invalid argument: ${args[i]}.`);

        if (i === 0 && arg === 'init') {
          options.init = resolve(cwd, next());
          break;
        }

        // NPM on windows passes verbatim arguments.
        if (process.platform === 'win32' && arg.length > 1) {
          const quot = arg[0] + arg[arg.length - 1];

          if (quot === '\'\'' || quot === '""')
            arg = arg.slice(1, -1);
        }

        files.push(arg);

        break;
      }
    }
  }

  // Only _arguments_ can imply other "modes".
  if (options.implyHeadless) {
    options.listen = true;
    options.headless = true;
  }

  if (options.implyListen)
    options.listen = true;

  if (options.implyOpen) {
    options.listen = true;
    options.open = true;
  }

  if (options.implySSL) {
    options.listen = true;
    options.ssl = true;
  }

  // `--listen` implies `--port=8080` if no "ui" options are chosen.
  // `--listen` implies `--port=$RANDOM` if "ui" options are chosen.
  if (options.listen && options.port === -1)
    options.port = (options.open || options.headless) ? 0 : 8080;

  // Sanity checks.
  if (options.fgrep && options.grep)
    throw new Error('Cannot use --fgrep with --grep.');

  if (options.invert && !options.fgrep && !options.grep)
    throw new Error('--invert requires --fgrep or --grep.');

  if (options.init) {
    if (options.delay)
      throw new Error('Cannot use --delay with init.');

    if (options.listen)
      throw new Error('Cannot use --listen with init.');

    if (options.watch)
      throw new Error('Cannot use --watch with init.');

    if (options.why)
      throw new Error('Cannot use --why with init.');
  }

  if (options.listen) {
    if (options.watch)
      throw new Error('Cannot use --watch with --listen.');

    if (options.why)
      throw new Error('Cannot use --why with --listen.');

    if (options.ssl) {
      if (!options.key)
        throw new Error('--ssl specified with no provided key.');

      if (!options.cert)
        throw new Error('--ssl specified with no provided cert.');
    }
  }

  // Set extensions to .{,m,c}js by default.
  if (extensions.length === 0)
    extensions.push('.js', '.mjs', '.cjs');

  // Make sure we have no duplicates.
  extensions = [...new Set(extensions)];

  // Find default file/dir if it exists.
  if (!options.init && files.length === 0) {
    const file = findExt('test', extensions);

    if (file)
      files.push(file);
  }

  // Process all files.
  files = globify(files);
  files = flatten(files, extensions, options.recurse);
  files = exclude(files, excludes);
  files = resolvify(files);

  if (options.sort)
    files.sort();

  if (!options.init && files.length === 0)
    throw new Error('No test files found.');

  // Note that file args aren't processed
  // in any extra way other than resolving
  // them against the current working dir.
  fileArgs = resolvify(fileArgs);

  // Quick and dirty check for file args.
  for (const file of fileArgs) {
    if (!exists(file))
      throw new Error(`File not found: ${string(file)}.`);
  }

  // Final step: file args run first.
  files = fileArgs.concat(files);

  // Extra extensions could be gotten as
  // side-effect of globbing. Add them to
  // the extensions array. Note that mocha
  // doesn't do this. Now that we're done
  // with file processing, these are
  // essentially just for watching files.
  if (options.watch) {
    extensions = mergeExts(extensions, files);

    if (!extensions.includes('.json'))
      extensions.push('.json');

    if (!extensions.includes('.node'))
      extensions.push('.node');

    if (!extensions.includes('.wasm'))
      extensions.push('.wasm');
  }

  if (options.watch) {
    if (watchFiles.length === 0) {
      watchFiles = getFiles('.', extensions);
    } else {
      watchFiles = globify(watchFiles);
      watchFiles = flatten(watchFiles, [], true);
    }
    watchFiles = exclude(watchFiles, watchIgnore);
    watchFiles = resolvify(watchFiles);
    watchFiles = watchFiles.map(x => require.resolve(x));
  }

  // Update options.
  options.extensions = extensions;
  options.fileArgs = fileArgs;
  options.files = files;
  options.watchFiles = watchFiles;

  // Optional file stream for reporter.
  if (typeof reporterOptions.output === 'string') {
    const {output} = reporterOptions;
    const path = output.replace(/^~\//, `${os.homedir()}/`);
    const file = resolve(cwd, path);

    mkdirp(dirname(file), 0o755);

    const stream = fs.createWriteStream(file);

    stream.on('error', (err) => {
      if (err.code === 'ERR_STREAM_WRITE_AFTER_END')
        return;

      if (err.message === 'write after end')
        return;

      exception(err);
    });

    options.stream = stream;
    options.colors = false;
  }

  return options;
}

/*
 * Error Handling
 */

function catcher(reject) {
  const onError = (error) => {
    const err = errorify(error);

    err.uncaught = true;
    err.exception = true;

    reject(err);
  };

  const onRejection = (reason, promise) => {
    const err = errorify(reason);

    err.uncaught = true;
    err.rejection = true;

    reject(err);
  };

  on('uncaughtException', onError);
  on('unhandledRejection', onRejection);

  return () => {
    off('uncaughtException', onError);
    off('unhandledRejection', onRejection);
  };
}

/*
 * Requires
 */

function handleRequire(file) {
  for (const ext of ['', '.js']) {
    if (exists(`${file}${ext}`)) {
      file = resolve(cwd, `${file}${ext}`);
      break;
    }
  }

  if (isAbsolute(file) && isImport(file))
    return imports(imports.pathToFileURL(file));

  const globalRequire = require('../lib/require.js');

  return globalRequire(file);
}

/*
 * Main
 */

(async () => {
  let options;

  try {
    options = await parseArgs();
  } catch (e) {
    if (e.code === 'ENOENT') {
      const file = relative(cwd, resolve(cwd, e.path));
      stderr.write(`File not found: ${string(file)}.\n`);
      return 1;
    }
    stderr.write(e.message + '\n');
    return 1;
  }

  if (options.init) {
    const browserify = require('../lib/server/browserify');
    const root = options.init;
    const opt = browserify.convert(options);
    const code = await browserify.compile('bmocha.js', opt);
    const html = await browserify.template('bmocha.html', style);

    mkdirp(root, 0o755);

    fs.writeFileSync(join(root, 'bmocha.js'), code);
    fs.writeFileSync(join(root, 'index.html'), html);
    fs.writeFileSync(join(root, 'tests.js'), '');

    return 0;
  }

  if (options.listen) {
    const Server = require('../lib/server');
    const server = new Server(options);
    const addr = await server.listen(options.port, 'localhost');
    const protocol = options.ssl ? 'https' : 'http';
    const url = `${protocol}://localhost:${addr.port}/`;

    server.on('error', (err) => {
      stderr.write('\n');
      stderr.write('Server Error:\n');
      stderr.write(err.stack + '\n');
    });

    if (options.headless) {
      server.cleanup = runHeadless(url, options);
      return -1;
    }

    stdout.write(`Server listening at: ${url}\n`);

    if (options.open)
      navigate(url, options.cmd);

    return -1;
  }

  env.BMOCHA = '1';
  env.NODE_TEST = '1';

  if (options.backend)
    env.NODE_BACKEND = options.backend;

  for (const key of Object.keys(options.env)) {
    const value = options.env[key];

    if (value != null)
      env[key] = value;
    else
      delete env[key];
  }

  const mocha = new Mocha(options);

  if (options.growl)
    mocha.notify = require('../lib/notify.js');

  if (!options.allowUncaught)
    mocha.catcher = catcher;

  if (options.watch)
    mocha.exit = (code) => {};
  else
    mocha.exit = exit;

  if (options.requires.length > 0) {
    for (const file of options.requires) {
      let mod;

      try {
        mod = await handleRequire(file);
      } catch (e) {
        if (e.code === 'MODULE_NOT_FOUND')
          exception(e.message);
        else
          exception(e);
        return -1;
      }

      await mocha.plugin(mod, file);
    }
  }

  const funcs = options.files.map(wrapImport);
  const code = await mocha.run(funcs);

  if (options.watch) {
    stdout.write('\x1b[?25l');

    bindExit((code) => {
      stdout.write('\x1b[?25h');
      if (code != null)
        exit(code);
    });

    const rerun = async () => {
      await mocha.abort();

      for (const file of options.watchFiles)
        delete require.cache[file];

      stdout.write('\n');

      await mocha.run(funcs);
    };

    stdin.resume();
    stdin.setEncoding('utf8');
    stdin.on('data', async (data) => {
      if (data.trim().toLowerCase() === 'rs') {
        try {
          await rerun();
        } catch (e) {
          exception(e);
        }
      }
    });

    watchFiles(options.watchFiles, rerun);

    return -1;
  }

  if (options.exit)
    exit(code);

  return code;
})().then((code) => {
  if (code !== -1) {
    process.exitCode = code;
    on('exit', () => exit(code));
  }
}).catch((err) => {
  exception(err);
});
