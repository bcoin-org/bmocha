#!/usr/bin/env node

/*!
 * bmocha - minimal mocha implementation
 * Copyright (c) 2018, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bmocha
 */

'use strict';

const assert = require('assert');
const fs = require('fs');
const os = require('os');
const path = require('path');
const glob = require('../vendor/glob');
const {Mocha, inspect, errorify} = require('../lib/bmocha.js');

const {
  basename,
  dirname,
  extname,
  join,
  normalize,
  relative,
  resolve
} = path;

const {
  Array,
  Boolean,
  Error,
  Math,
  Object,
  process,
  RegExp
} = global;

const cwd = process.cwd();
const {argv, env, stdout, stderr, exit} = process;
const on = process.on.bind(process);
const off = process.removeListener.bind(process);

/*
 * Constants
 */

const VERSION = '1.0.1';

const HELP = `
  Usage: bmocha [options] [files]
         bmocha debug [options] [files]

  Options:

    -A, --async-only        require all tests to use a callback or promise
                            (default: false)
    --allow-uncaught        enable uncaught errors to propagate (default: false)
    -b, --bail              bail after first test failure (default: false)
    -c, --colors            force enabling of colors
    -C, --no-colors         force disabling of colors
    --config <path>         path to config file (default: nearest rc file)
    --check-leaks           check for global variable leaks (default: false)
    --chrome <path>         chrome binary to use for headless mode
    --delay                 delay initial execution of root suite
                            (default: false)
    --diff                  show diff on failure (default: true)
    --exclude <file>        a file to ignore
    --exit                  force shutdown of the event loop after test run
                            (default: false)
    --extension <ext>       file extension(s) to load and/or watch (default: js)
    -f, --fgrep <string>    only run tests containing <string>
    --file <file>           include a file to be ran during the suite
    --forbid-only           fail if exclusive test(s) encountered
                            (default: false)
    --forbid-pending        fail if pending test(s) encountered (default: false)
    --full-trace            display full stack traces (default: false)
    -g, --grep <pattern>    only run tests matching <pattern>
    -G, --growl             enable growl notifications (noop) (default: false)
    --globals <names>       allow the given comma-delimited global <names>
    -H, --headless          run tests in headless chrome (default: false)
    -h, --help              output usage information
    -i, --invert            inverts --grep and --fgrep matches (default: false)
    --inline-diffs          display actual/expected differences inline (noop)
                            (default: false)
    --interfaces            display available interfaces
    -l, --listen            serve client-side test files (requires browserify)
                            (default: false)
    -m, --cmd <cmd>         set browser command (default: $BROWSER)
    -o, --open              open browser after serving (default: false)
    -O, --reporter-options  reporter-specific options
    --opts <path>           path to "mocha.opts" (default: ./test/mocha.opts)
    --package <path>        path to package.json for config
                            (default: ./package.json)
    -p, --port <port>       port to listen on (default: 8080)
    -R, --reporter <name>   specify the reporter to use (default: spec)
    -r, --require <name>    require the given module
    --recursive             include sub directories (default: false)
    --reporters             display available reporters
    --retries <times>       set numbers of time to retry a failed test case
                            (default: 0)
    -s, --slow <ms>         "slow" test threshold in milliseconds (default: 75)
    -S, --sort              sort test files (default: false)
    --ssl                   use ssl to listen (default: false)
    --ssl-cert <path>       path to ssl cert file
    --ssl-ignore            ignore certificate errors (headless)
                            (default: false)
    --ssl-key <path>        path to ssl key file
    -t, --timeout <ms>      set test-case timeout in milliseconds
                            (default: 2000)
    --timeouts              enables timeouts (default: true)
    -u, --ui <name>         specify user-interface (bdd) (default: bdd)
    -V, --version           output the version number
    -w, --watch             watch files in the current working directory
                            (default: false)
    -z, --console           use console in browser (default: false)
`;

const INTERFACES = `
    bdd
`;

const REPORTERS = `
    doc - html documentation
    dot - dot matrix
    json - single json object
    json-stream - newline delimited json events
    landing - unicode landing strip
    list - spec-style listing
    markdown - markdown documentation (github flavour)
    min - minimal reporter (great with --watch)
    nyan - nyan cat!
    progress - progress bar
    spec - hierarchical spec list
    tap - test-anything-protocol
    xunit - xunit reporter
`;

const DEFAULT_OPTS = resolve(cwd, 'test', 'mocha.opts');
const DEFAULT_PKG = resolve(cwd, 'package.json');
const BIN_PATH = resolve(__dirname, '..', 'bin');
const LIB_PATH = resolve(__dirname, '..', 'lib');
const IN_MOCHA = basename(cwd) === 'bmocha';

/*
 * Helpers
 */

function string(str) {
  assert(typeof str === 'string');
  return JSON.stringify(str);
}

function wrapRequire(file) {
  assert(typeof file === 'string');

  return () => {
    const path = resolve(cwd, file);

    delete require.cache[path];

    require(path);
  };
}

function readdir(path) {
  assert(typeof path === 'string');
  return fs.readdirSync(path).map((name) => {
    return join(path, name);
  });
}

function exists(file) {
  assert(typeof file === 'string');
  try {
    fs.statSync(file);
    return true;
  } catch (e) {
    if (e.code === 'ENOENT')
      return false;
    throw e;
  }
}

function mkdirp(path, mode) {
  if (mode == null)
    mode = 0o777;

  assert(typeof path === 'string');
  assert((mode >>> 0) === mode);

  const paths = [];

  let dir = normalize(path);

  for (;;) {
    paths.push(dir);

    const next = dirname(dir);

    if (next === dir)
      break;

    dir = next;
  }

  paths.reverse();

  for (const path of paths) {
    if (!exists(path))
      fs.mkdirSync(path, mode);
  }
}

function exception(err, code) {
  if (err && err.stack)
    err = err.stack;

  code >>>= 0;

  stderr.write(err + '\n');
  exit(code || 1);
}

/*
 * Test File Traversal
 */

function globify(files) {
  assert(Array.isArray(files));

  const out = [];

  const options = {
    cwd,
    nosort: true,
    silent: true
  };

  for (const file of files) {
    if (glob.hasMagic(file, options)) {
      const result = glob.sync(file, options);

      if (result.length === 0)
        throw new Error(`Could not resolve pattern: ${string(file)}.`);

      out.push(...result);

      continue;
    }

    if (!exists(file)) {
      // To mimic mocha more closely, we could do:
      //
      //   if (exists(file + '.js')) {
      //     out.push(file + '.js');
      //     continue;
      //   }
      //
      // But this seems messy and non-explicit.
      // It also doesn't account for custom extensions.
      throw new Error(`File not found: ${string(file)}.`);
    }

    out.push(file);
  }

  return out;
}

function flatten(files, extensions, recurse = false) {
  assert(Array.isArray(files));
  assert(Array.isArray(extensions));
  assert(typeof recurse === 'boolean');

  for (const file of files)
    assert(typeof file === 'string');

  for (const ext of extensions) {
    assert(typeof ext === 'string');
    assert(ext.length > 0 && ext[0] === '.');
  }

  return walk(files, extensions, recurse, 0, []);
}

function walk(files, extensions, recurse, depth, out) {
  for (const file of files) {
    const stat = fs.statSync(file);

    if (stat.isDirectory()) {
      // Avoid symlink loops (diverges from mocha).
      if (fs.lstatSync(file).isSymbolicLink())
        continue;

      // Without the recurse option,
      // mocha delves one level deep.
      if (recurse || depth === 0)
        walk(readdir(file), extensions, recurse, depth + 1, out);

      continue;
    }

    // If a file was given to us explicity,
    // do not filter. The result of a glob is
    // considered explicit (mimic mocha behavior).
    if (depth === 0) {
      if (!stat.isFile()) {
        // Mocha throws with a nasty error
        // in this case. We can do better.
        throw new Error(`Not a regular file: ${string(file)}.`);
      }
      out.push(file);
      continue;
    }

    // Files only.
    if (!stat.isFile())
      continue;

    // No dotfiles.
    if (basename(file)[0] === '.')
      continue;

    // Only our specific extensions.
    if (extensions.length > 0) {
      const ext = extname(file);

      if (extensions.indexOf(ext) === -1)
        continue;
    }

    out.push(file);
  }

  return out;
}

function exclude(files, excludes) {
  assert(Array.isArray(files));
  assert(Array.isArray(excludes));

  return files.filter((name) => {
    return excludes.every((pattern) => {
      return !glob.minimatch(name, pattern);
    });
  });
}

function resolvify(files) {
  assert(Array.isArray(files));
  return files.map(file => resolve(cwd, file));
}

/*
 * Watching Helpers
 */

function getFiles(root, extensions, out = []) {
  assert(typeof root === 'string');
  assert(Array.isArray(extensions));
  assert(Array.isArray(out));

  root = resolve(cwd, root);

  for (const name of fs.readdirSync(root)) {
    if (name === '.git' || name === 'node_modules')
      continue;

    const file = join(root, name);
    const stat = fs.lstatSync(file);

    if (stat.isDirectory()) {
      getFiles(file, extensions, out);
      continue;
    }

    // Files only.
    if (!stat.isFile())
      continue;

    // Only our specific extensions.
    if (extensions.length > 0) {
      const ext = extname(name);

      if (extensions.indexOf(ext) === -1)
        continue;
    }

    // Ignore everything in
    // our own bin and lib.
    if (IN_MOCHA) {
      if (file.startsWith(BIN_PATH)
          || file.startsWith(LIB_PATH)) {
        continue;
      }
    }

    out.push(file);
  }

  return out;
}

function watchFiles(files, callback) {
  assert(Array.isArray(files));
  assert(typeof callback === 'function');

  const options = { interval: 100 };

  const cb = async (current, previous) => {
    const prev = previous.mtime.getTime();
    const cur = current.mtime.getTime();

    if (prev >= cur)
      return;

    try {
      await callback();
    } catch (e) {
      exception(e);
    }
  };

  for (const file of files)
    fs.watchFile(file, options, cb);
}

/*
 * Process Helpers
 */

function spawn(file, args, shell = false) {
  const cp = require('child_process');

  const ps = cp.spawn(file, args, {
    cwd,
    env,
    detached: true,
    stdio: 'ignore',
    shell
  });

  ps.on('error', () => {});

  ps.unref();

  return ps;
}

function navigate(url, cmd) {
  assert(typeof url === 'string');
  assert(cmd == null || typeof cmd === 'string');

  // Any OS:
  if (cmd) {
    if (cmd.indexOf('%s') !== -1) {
      cmd = cmd.replace(/%s/g, url);
      return spawn(cmd, [], true);
    }

    return spawn(cmd, [url], true);
  }

  // Windows:
  // https://stackoverflow.com/questions/3739327
  if (process.platform === 'win32')
    return spawn('explorer', [url]);

  // OSX:
  // https://superuser.com/questions/85151
  if (process.platform === 'darwin')
    return spawn('open', [url]);

  // Unix:
  const name = env.BROWSER;

  if (!name)
    return spawn('xdg-open', [url]);

  if (/(?:chrome|chromium)/i.test(name))
    return spawn(name, [`--app=${url}`]);

  return spawn(name, [url]);
}

function findFile(files) {
  assert(Array.isArray(files));

  for (const file of files) {
    if (exists(file))
      return file;
  }

  return null;
}

function findChrome() {
  if (env.BMOCHA_CHROMIUM)
    return env.BMOCHA_CHROMIUM;

  if (env.BMOCHA_CHROME)
    return env.BMOCHA_CHROME;

  // See: https://github.com/karma-runner/karma-chrome-launcher
  if (process.platform === 'darwin') {
    return findFile([
      '/Applications/Chromium.app/Contents/MacOS/Chromium',
      '/Applications/Google Chrome.app/Contents/MacOS/Google Chrome'
    ]);
  }

  if (process.platform === 'win32') {
    // https://stackoverflow.com/questions/40674914
    const names = [
      '\\Chromium\\Application\\chromium.exe',
      '\\Chromium\\chromium.exe',
      '\\Google\\Chrome\\Application\\chrome.exe', // Windows 10
      '\\Google\\Application\\chrome.exe', // Windows 7
      '\\Google\\Chrome\\chrome.exe' // Windows XP/Vista
    ];

    const files = [];

    for (const name of names) {
      for (const dir of [env.LOCALAPPDATA,
                         env.PROGRAMFILES,
                         env['PROGRAMFILES(X86)']]) {
        if (!dir || dir.length === 0)
          continue;

        files.push(join(dir, name));
      }
    }

    return findFile(files);
  }

  if (!env.PATH)
    return null;

  const files = [];

  for (const name of ['chromium',
                      'google-chrome',
                      'google-chrome-stable']) {
    for (const dir of env.PATH.split(':')) {
      if (dir.length === 0)
        continue;

      files.push(join(dir, name));
    }
  }

  return findFile(files);
}

function bindExit(handler) {
  assert(typeof handler === 'function');

  const onSighup = () => exit(1 | 0x80);
  const onSigint = () => exit(2 | 0x80);
  const onSigterm = () => exit(15 | 0x80);
  const onError = err => exception(err);

  process.once('exit', handler);

  if (process.listenerCount('SIGHUP') === 0)
    process.once('SIGHUP', onSighup);

  if (process.listenerCount('SIGINT') === 0)
    process.once('SIGINT', onSigint);

  if (process.listenerCount('SIGTERM') === 0)
    process.once('SIGTERM', onSigterm);

  if (process.listenerCount('uncaughtException') === 0)
    process.once('uncaughtException', onError);

  if (process.listenerCount('unhandledRejection') === 0)
    process.once('unhandledRejection', onError);

  process.on('newListener', (name) => {
    switch (name) {
      case 'SIGHUP':
        process.removeListener(name, onSighup);
        break;
      case 'SIGINT':
        process.removeListener(name, onSigint);
        break;
      case 'SIGTERM':
        process.removeListener(name, onSigterm);
        break;
      case 'uncaughtException':
        process.removeListener(name, onError);
        break;
      case 'unhandledRejection':
        process.removeListener(name, onError);
        break;
    }
  });
}

function runHeadless(url, chrome, extra = []) {
  assert(typeof url === 'string');
  assert(chrome == null || typeof chrome === 'string');
  assert(Array.isArray(extra));

  const cp = require('child_process');

  const file = chrome || findChrome();

  if (!file)
    throw new Error('Could not find chrome binary.');

  const port = 1000 + Math.floor(Math.random() * (0x10000 - 1000));

  const args = [
    '--headless',
    '--disable-gpu',
    `--remote-debugging-port=${port}`,
    ...extra,
    url
  ];

  let output = '';

  const onData = (data) => {
    if (output.length > (1 << 20))
      output = '';
    output += data;
  };

  const onError = (err) => {
    if (err.code === 'ENOENT')
      exception(`Chrome not found: ${err.path}.`);
    else
      exception(err);
  };

  const onExit = (code, signal) => {
    code >>>= 0;

    stderr.write('Chrome exited unexpectedly ');
    stderr.write(`(code=${code}, signal=${signal}).\n`);

    if (output.length > 0) {
      stderr.write('\n');
      stderr.write(output);
      stderr.write('\n');
    }

    if (code === 0)
      code = 1;

    exit(code);
  };

  const ps = cp.spawn(file, args, {
    cwd,
    env,
    detached: false,
    stdio: ['ignore', 'pipe', 'pipe'],
    shell: false
  });

  ps.stdout.unref();
  ps.stdout.setEncoding('utf8');
  ps.stdout.on('error', () => {});
  ps.stdout.on('data', onData);

  ps.stderr.unref();
  ps.stderr.setEncoding('utf8');
  ps.stderr.on('error', () => {});
  ps.stderr.on('data', onData);

  ps.unref();
  ps.on('error', onError);
  ps.on('exit', onExit);

  bindExit(() => {
    ps.removeListener('exit', onExit);
    ps.kill('SIGTERM');
  });

  return [[file, ...args], ps];
}

/*
 * Config Parsing
 */

function findConfig(root) {
  assert(typeof root === 'string');

  let dir = normalize(root);

  for (;;) {
    for (const name of ['.mocharc.js',
                        '.mocharc.yaml',
                        '.mocharc.yml',
                        '.mocharc.jsonc',
                        '.mocharc.json']) {
      const file = join(dir, name);

      if (exists(file))
        return file;
    }

    const next = dirname(dir);

    if (next === dir)
      break;

    dir = next;
  }

  return null;
}

function parseConfig(json) {
  assert(json && typeof json === 'object');

  const args = [];

  for (const key of Object.keys(json)) {
    const value = json[key];

    switch (typeof value) {
      case 'boolean':
        args.push(value ? `--${key}` : `--no-${key}`);
        break;
      case 'number':
      case 'string':
        args.push(`--${key}`);
        args.push(String(value));
        break;
      case 'object':
        if (Array.isArray(value)) {
          for (const item of value) {
            args.push(`--${key}`);
            args.push(String(item));
          }
        } else if (value instanceof RegExp) {
          args.push(value.source);
        }
        break;
    }
  }

  return args;
}

function readJS(file) {
  assert(typeof file === 'string');
  return require(resolve(cwd, file));
}

function readJSON(file) {
  assert(typeof file === 'string');
  const text = fs.readFileSync(file, 'utf8');
  return JSON.parse(text);
}

/*
 * Argument Parsing
 */

function getArgs(argv) {
  assert(Array.isArray(argv));

  const args = [];
  const out = [];

  // Normalize process arg vector.
  for (let i = 0; i < argv.length; i++) {
    const arg = argv[i];

    assert(typeof arg === 'string');

    if (arg.startsWith('--')) {
      // e.g. --opt
      const index = arg.indexOf('=');
      if (index !== -1) {
        // e.g. --opt=val
        args.push(arg.substring(0, index));
        args.push(arg.substring(index + 1));
      } else {
        args.push(arg);
      }
    } else if (arg.startsWith('-')) {
      if (arg.length > 2) {
        // e.g. -abc
        for (let j = 1; j < arg.length; j++)
          args.push(`-${arg.charAt(j)}`);
      } else {
        // e.g. -a
        args.push(arg);
      }
    } else {
      // e.g. foo
      args.push(arg);
    }
  }

  // Quickly parse through args
  // to find config files.
  let config = null;
  let opts = null;
  let pkg = null;

  for (let i = 0; i < args.length; i++) {
    switch (args[i]) {
      case '-h':
      case '--help':
      case '--interfaces':
      case '--reporters':
      case '-V':
      case '--version':
        return args;
      case '--config': {
        if (i + 1 < args.length)
          config = args[++i];
        break;
      }
      case '--no-config': {
        config = false;
        break;
      }
      case '--opts': {
        if (i + 1 < args.length)
          opts = args[++i];
        break;
      }
      case '--no-opts': {
        opts = false;
        break;
      }
      case '--package': {
        if (i + 1 < args.length)
          pkg = args[++i];
        break;
      }
      case '--no-package': {
        pkg = false;
        break;
      }
    }
  }

  // Parse main config (rc) file.
  if (config === null)
    config = findConfig(cwd);

  if (typeof config === 'string') {
    const ext = extname(config);

    let json = null;

    switch (ext) {
      case '.js':
        json = readJS(config);
        break;
      case '.json':
        json = readJSON(config);
        break;
      default:
        stderr.write('Warning: ');
        stderr.write(`cannot read ${ext} config: `);
        stderr.write(`${string(config)}.\n`);
        break;
    }

    if (json && typeof json === 'object') {
      out.push(...parseConfig(json));

      if (pkg === null && typeof json.package !== undefined)
        pkg = json.package;

      if (opts === null && typeof json.opts !== undefined)
        opts = json.opts;
    }
  }

  // Parse package.json "mocha" field.
  if (pkg === null && exists(DEFAULT_PKG))
    pkg = DEFAULT_PKG;

  if (typeof pkg === 'string') {
    const data = readJSON(pkg);

    if (!data || typeof data !== 'object')
      throw new Error(`Invalid package.json: ${string(pkg)}.`);

    const json = data.mocha;

    if (json && typeof json === 'object') {
      out.push(...parseConfig(json));

      if (opts === null && typeof json.opts !== undefined)
        opts = json.opts;
    }
  }

  // Parse legacy test/mocha.opts file.
  if (opts === null && exists(DEFAULT_OPTS))
    opts = DEFAULT_OPTS;

  if (typeof opts === 'string') {
    const text = fs.readFileSync(opts, 'utf8');
    const args = text.replace(/^#.*$/gm, '')
                     .replace(/\\\s/g, '%20')
                     .split(/\s+/);

    for (const arg of args) {
      if (arg.length === 0)
        continue;

      out.push(arg.replace(/%20/g, ' '));
    }
  }

  // Args go on last (higher precedence).
  out.push(...args);

  return out;
}

function parseArgs() {
  const options = {
    __proto__: null,
    asyncOnly: false,
    bail: false,
    cert: null,
    checkLeaks: false,
    chrome: null,
    cmd: '',
    colors: Boolean(stdout.isTTY),
    console: false,
    delay: false,
    diff: true,
    excludes: [],
    exit: false,
    extensions: [],
    fgrep: '',
    forbidOnly: false,
    forbidPending: false,
    fileArgs: [],
    files: [],
    fullTrace: false,
    global: true,
    globals: [],
    grep: null,
    growl: false,
    headless: false,
    invert: false,
    key: null,
    listen: false,
    open: false,
    port: -1,
    recurse: false,
    reporter: 'spec',
    reporterOptions: Object.create(null),
    requires: [],
    retries: 0,
    slow: 75,
    ssl: false,
    sslIgnore: false,
    sort: false,
    stream: stdout,
    timeout: 2000,
    timeouts: true,
    uncaught: false,
    watch: false,
    windows: process.platform === 'win32'
  };

  let {
    excludes,
    extensions,
    fileArgs,
    files,
    reporterOptions
  } = options;

  let i = 0;
  let value = true;

  const args = getArgs(argv.slice(2));

  const ensure = () => {
    if (!value)
      throw new Error(`Invalid argument: ${args[i]}.`);
  };

  const next = () => {
    ensure();

    if (i + 1 >= args.length || args[i + 1].length === 0)
      throw new Error(`Invalid option for ${args[i]}.`);

    return args[++i];
  };

  for (; i < args.length; i++) {
    let arg = args[i];

    value = true;

    if (arg.startsWith('--no-')) {
      arg = `--${arg.substring(5)}`;
      value = false;
    }

    switch (arg) {
      case '-A':
      case '--async-only': {
        options.asyncOnly = value;
        break;
      }

      case '--allow-uncaught': {
        options.uncaught = value;
        break;
      }

      case '-b':
      case '--bail': {
        options.bail = value;
        break;
      }

      case '-c':
      case '--color':
      case '--colors': {
        options.colors = value;
        break;
      }

      case '-C': {
        options.colors = false;
        break;
      }

      case '--config': {
        if (value)
          next();
        break;
      }

      case '--check-leaks': {
        options.checkLeaks = value;
        break;
      }

      case '--chrome': {
        options.listen = true;
        options.open = true;
        options.headless = true;
        options.chrome = next();
        break;
      }

      case '--delay': {
        options.delay = value;
        break;
      }

      case '--diff': {
        options.diff = value;
        break;
      }

      case '--exclude': {
        excludes.push(next());
        break;
      }

      case '--exit': {
        options.exit = value;
        break;
      }

      case '--extension':
      case '--watch-extensions': {
        for (let ext of next().split(',')) {
          if (ext.length === 0 || ext === '.')
            throw new Error(`Invalid file extension: ${ext}.`);

          if (ext[0] !== '.')
            ext = '.' + ext;

          extensions.push(ext);
        }
        break;
      }

      case '-f':
      case '--fgrep': {
        options.fgrep = value ? next() : '';
        break;
      }

      case '--file': {
        fileArgs.push(next());
        break;
      }

      case '--forbid-only': {
        options.forbidOnly = value;
        break;
      }

      case '--forbid-pending': {
        options.forbidPending = value;
        break;
      }

      case '--full-trace': {
        options.fullTrace = value;
        break;
      }

      case '-g':
      case '--grep': {
        options.grep = value ? new RegExp(next()) : null;
        break;
      }

      case '-G':
      case '--growl': {
        options.growl = value;
        break;
      }

      case '--global':
      case '--globals': {
        const globals = next().split(',');

        if (globals.indexOf('') !== -1)
          throw new Error(`Invalid globals: ${args[i]}.`);

        options.globals = globals;

        break;
      }

      case '-H':
      case '--headless': {
        options.listen = value;
        options.open = value;
        options.headless = value;
        break;
      }

      case '-h':
      case '--help': {
        ensure();
        stdout.write(HELP + '\n');
        exit(0);
        break;
      }

      case '-i':
      case '--invert': {
        options.invert = value;
        break;
      }

      case '--inline-diffs': {
        break;
      }

      case '--interfaces': {
        ensure();
        stdout.write(INTERFACES + '\n');
        exit(0);
        break;
      }

      case '-l':
      case '--listen': {
        options.listen = value;
        break;
      }

      case '-m':
      case '--cmd': {
        options.listen = true;
        options.open = true;
        options.cmd = next();
        break;
      }

      case '-o':
      case '--open': {
        options.listen = value;
        options.open = value;
        break;
      }

      case '-O':
      case '--reporter-option':
      case '--reporter-options': {
        for (const opt of next().split(',')) {
          const parts = opt.split('=');

          if (parts.length > 2 || parts.length === 0)
            throw new Error(`Invalid reporter option: ${opt}.`);

          if (parts.length === 2)
            reporterOptions[parts[0]] = parts[1];
          else
            reporterOptions[parts[0]] = true;
        }

        break;
      }

      case '--opts': {
        if (value)
          next();
        break;
      }

      case '--package': {
        if (value)
          next();
        break;
      }

      case '-p':
      case '--port': {
        const port = next() >>> 0;

        if (port > 0xffff)
          throw new Error(`Invalid port: ${port}.`);

        options.port = port;
        options.listen = true;

        break;
      }

      case '-R':
      case '--reporter': {
        options.reporter = next();
        break;
      }

      case '-r':
      case '--require': {
        let file = next();

        if (exists(file) || exists(`${file}.js`))
          file = resolve(cwd, file);

        options.requires.push(file);

        break;
      }

      case '--recursive': {
        options.recurse = value;
        break;
      }

      case '--reporters': {
        ensure();
        stdout.write(REPORTERS + '\n');
        exit(0);
        break;
      }

      case '--retries': {
        options.retries = value ? next() >>> 0 : 0;
        break;
      }

      case '-s':
      case '--slow': {
        options.slow = next() >>> 0;
        break;
      }

      case '-S':
      case '--sort': {
        options.sort = value;
        break;
      }

      case '--ssl': {
        options.listen = value;
        options.ssl = value;
        break;
      }

      case '--cert':
      case '--ssl-cert': {
        options.listen = true;
        options.ssl = true;
        options.cert = fs.readFileSync(next());
        break;
      }

      case '--ssl-ignore': {
        options.headless = value;
        options.open = value;
        options.listen = value;
        options.ssl = value;
        options.sslIgnore = value;
        break;
      }

      case '--key':
      case '--ssl-key': {
        options.listen = true;
        options.ssl = true;
        options.key = fs.readFileSync(next());
        break;
      }

      case '-t':
      case '--timeout': {
        options.timeout = value ? next() >>> 0 : 0;
        break;
      }

      case '--timeouts': {
        options.timeouts = value;
        break;
      }

      case '-u':
      case '--ui': {
        const ui = next();

        if (ui !== 'bdd')
          throw new Error(`Invalid interface: ${ui}.`);

        break;
      }

      case '-V':
      case '--version': {
        ensure();
        stdout.write(VERSION + '\n');
        exit(0);
        break;
      }

      case '-w':
      case '--watch': {
        options.watch = value;
        break;
      }

      case '-z':
      case '--console': {
        options.console = value;
        break;
      }

      default: {
        if (arg.length === 0 || arg[0] === '-')
          throw new Error(`Invalid argument: ${args[i]}.`);

        if (i === 0 && arg === 'init')
          throw new Error('"init" is not implemented.');

        files.push(arg);

        break;
      }
    }
  }

  if (options.listen) {
    if (options.port === -1)
      options.port = options.open ? 0 : 8080;
  }

  if (options.ssl) {
    if (!options.key)
      throw new Error('SSL specified with no provided key.');

    if (!options.cert)
      throw new Error('SSL specified with no provided cert.');
  }

  if (files.length === 0) {
    if (exists('test'))
      files.push('test');
    else if (exists('test.js'))
      files.push('test.js');
  }

  if (extensions.length === 0)
    extensions.push('.js');

  files = globify(files);
  files = flatten(files, extensions, options.recurse);
  files = exclude(files, excludes);
  files = resolvify(files);

  if (options.sort)
    files.sort();

  // Note that file args aren't processed
  // in any extra way other than resolving
  // them against the current working dir.
  fileArgs = resolvify(fileArgs);

  // Quick and dirty check for file args.
  for (const file of fileArgs) {
    if (!exists(file))
      throw new Error(`File not found: ${string(file)}.`);
  }

  // Final step: file args run first.
  files = fileArgs.concat(files);

  if (files.length === 0)
    throw new Error('No test files found.');

  options.fileArgs = fileArgs;
  options.files = files;

  if (typeof reporterOptions.output === 'string') {
    const {output} = reporterOptions;
    const path = output.replace(/^~\//, `${os.homedir()}/`);
    const file = resolve(cwd, path);

    mkdirp(dirname(file), 0o755);

    const stream = fs.createWriteStream(file);

    stream.on('error', (err) => {
      if (err.code === 'ERR_STREAM_WRITE_AFTER_END')
        return;

      if (err.message === 'write after end')
        return;

      exception(err);
    });

    options.stream = stream;
    options.colors = false;
  }

  return options;
}

/*
 * Error Handling
 */

function catcher(reject) {
  const onError = (error) => {
    const err = errorify(error);

    err.uncaught = true;
    err.exception = true;

    reject(err);
  };

  const onRejection = (reason, promise) => {
    const err = errorify(reason);

    err.uncaught = true;
    err.rejection = true;

    reject(err);
  };

  const onMultiple = (type, promise, value) => {
    const kind = inspect.type(value);
    const err = new Error(`Multiple ${type}s detected for ${kind}.`);

    err.uncaught = true;
    err.multiple = true;
    err.display = true;
    err.value = value;

    reject(err);
  };

  on('uncaughtException', onError);
  on('unhandledRejection', onRejection);
  on('multipleResolves', onMultiple);

  return () => {
    off('uncaughtException', onError);
    off('unhandledRejection', onRejection);
    off('multipleResolves', onMultiple);
  };
}

/*
 * Main
 */

(async () => {
  let options;

  try {
    options = parseArgs();
  } catch (e) {
    if (e.code === 'ENOENT') {
      const file = relative(cwd, resolve(cwd, e.path));
      stderr.write(`File not found: ${string(file)}.\n`);
      return 1;
    }
    stderr.write(e.message + '\n');
    return 1;
  }

  if (options.listen) {
    const Server = require('../lib/server');
    const server = new Server(options);
    const addr = await server.listen(options.port, 'localhost');
    const protocol = options.ssl ? 'https' : 'http';
    const url = `${protocol}://localhost:${addr.port}/`;
    const chromeOptions = [];

    server.on('error', (err) => {
      stderr.write('\n');
      stderr.write('Server Error:\n');
      stderr.write(err.stack + '\n');
    });

    if (options.ssl && options.sslIgnore)
      chromeOptions.push('--ignore-certificate-errors');

    if (options.headless) {
      runHeadless(url, options.chrome, chromeOptions);
      return -1;
    }

    stdout.write(`Server listening at: ${url}\n`);

    if (options.open)
      navigate(url, options.cmd);

    return -1;
  }

  env.BMOCHA = '1';
  env.NODE_TEST = '1';

  const mocha = new Mocha(options);

  if (options.growl)
    mocha.notify = require('../lib/notify');

  if (!options.uncaught)
    mocha.catcher = catcher;

  if (options.watch)
    mocha.exit = (code) => {};
  else
    mocha.exit = exit;

  module.paths.push(cwd, join(cwd, 'node_modules'));

  for (const file of options.requires)
    require(file);

  const funcs = options.files.map(wrapRequire);
  const code = await mocha.run(funcs);

  if (options.watch) {
    const files = getFiles(cwd, options.extensions);

    stdout.write('\x1b[?25l');

    bindExit(() => {
      stdout.write('\x1b[?25h');
    });

    watchFiles(files, async () => {
      await mocha.abort();

      for (const file of files)
        delete require.cache[file];

      stdout.write('\n');

      await mocha.run(funcs);
    });

    return -1;
  }

  if (options.exit)
    exit(code);

  return code;
})().then((code) => {
  if (code !== -1) {
    process.exitCode = code;
    on('exit', () => exit(code));
  }
}).catch((err) => {
  exception(err);
});
