#!/usr/bin/env node

/*!
 * bmocha - minimal mocha implementation
 * Copyright (c) 2018, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bmocha
 */

/* eslint no-control-regex: "off" */

'use strict';

const assert = require('assert');
const fs = require('fs');
const os = require('os');
const path = require('path');
const glob = require('../vendor/glob');
const {Mocha, inspect, errorify} = require('../lib/bmocha.js');

const {
  basename,
  dirname,
  extname,
  join,
  relative,
  resolve
} = path;

const {
  Array,
  Boolean,
  Error,
  Math,
  Object,
  process,
  RegExp
} = global;

const cwd = process.cwd();
const {argv, env, stdout, stderr, exit} = process;
const on = process.on.bind(process);
const off = process.removeListener.bind(process);

const parts = process.version.split(/[^\d]/);
const version = (0
  + (parts[1] & 0xff) * 0x10000
  + (parts[2] & 0xff) * 0x00100
  + (parts[3] & 0xff) * 0x00001);

/*
 * Constants
 */

const VERSION = '1.0.1';

const HELP = `
  Usage: bmocha [options] [files]
         bmocha debug [options] [files]

  Options:

    -A, --async-only        require all tests to use a callback or promise
    --allow-uncaught        enable uncaught errors to propagate
    -b, --bail              bail after first test failure
    -c, --colors            force enabling of colors
    -C, --no-colors         force disabling of colors
    --config <path>         path to config file (unimplemented)
    --check-leaks           check for global variable leaks
    --chrome <path>         chrome binary to use for headless mode
    --diff                  show diff on failure
    --exclude <file>        a file to ignore
    --exit                  force shutdown of the event loop after test run
    --extension             file extension(s) to load and/or watch
    -f, --fgrep <string>    only run tests containing <string>
    --file <file>           include a file to be ran during the suite
    --forbid-only           fail if exclusive test(s) encountered
    --forbid-pending        fail if pending test(s) encountered
    --full-trace            display full stack traces (noop)
    -g, --grep <pattern>    only run tests matching <pattern>
    -G, --growl             enable growl notifications (unimplemented)
    --globals               allow the given comma-delimited global [names]
    -H, --headless          run tests in headless chrome
    -h, --help              output usage information
    -i, --invert            inverts --grep and --fgrep matches
    --inline-diffs          display actual/expected differences inline (noop)
    --interfaces            display available interfaces
    -l, --listen            serve client-side test files (requires browserify)
    -m, --cmd <cmd>         set browser command
    --no-diff               do not show diff on failure
    --no-opts               do not load opts file
    --no-timeouts           disables timeouts
    -o, --open              open browser after serving
    -O, --reporter-options  reporter-specific options
    --opts <path>           path to "mocha.opts"
    --package <path>        path to package.json for config (unimplemented)
    -p, --port <port>       port to listen on [8080]
    -R, --reporter <name>   specify the reporter to use (default: spec)
    -r, --require <name>    require the given module
    --recursive             include sub directories
    --reporters             display available reporters
    --retries <times>       set numbers of time to retry a failed test case
    -s, --slow <ms>         "slow" test threshold in milliseconds [75]
    -S, --sort              sort test files
    --ssl                   use ssl to listen
    --ssl-cert              path to ssl cert file
    --ssl-ignore            ignore certificate errors (headless) [false]
    --ssl-key               path to ssl key file
    -t, --timeout <ms>      set test-case timeout in milliseconds [2000]
    -u, --ui <name>         specify user-interface (bdd) (default: bdd)
    -V, --version           output the version number
    -w, --watch             watch files in the current working directory
    -z, --console           use console in browser
`;

const INTERFACES = `
    bdd
`;

const REPORTERS = `
    doc - html documentation
    dot - dot matrix
    json - single json object
    json-stream - newline delimited json events
    landing - unicode landing strip
    list - spec-style listing
    markdown - markdown documentation (github flavour)
    min - minimal reporter (great with --watch)
    nyan - nyan cat!
    progress - progress bar
    spec - hierarchical spec list
    tap - test-anything-protocol
    xunit - xunit reporter
`;

const DEFAULT_OPTS = './test/mocha.opts';
const BIN = resolve(__dirname, '..', 'bin');
const LIB = resolve(__dirname, '..', 'lib');

/*
 * Helpers
 */

function wrap(file) {
  assert(typeof file === 'string');

  return () => {
    const path = resolve(cwd, file);

    delete require.cache[path];

    require(path);
  };
}

function readdir(path) {
  assert(typeof path === 'string');
  return fs.readdirSync(path).map((name) => {
    return join(path, name);
  });
}

function exists(file) {
  assert(typeof file === 'string');
  try {
    fs.statSync(file);
    return true;
  } catch (e) {
    if (e.code !== 'ENOENT')
      throw e;
    return false;
  }
}

function string(str) {
  assert(typeof str === 'string');
  return JSON.stringify(str);
}

function globify(files) {
  assert(Array.isArray(files));

  const out = [];

  const options = {
    cwd,
    nosort: true,
    silent: true
  };

  for (const file of files) {
    if (glob.hasMagic(file, options)) {
      const result = glob.sync(file, options);

      if (result.length === 0)
        throw new Error(`Could not resolve pattern: ${string(file)}.`);

      out.push(...result);

      continue;
    }

    if (!exists(file)) {
      // To mimic mocha more closely, we could do:
      //
      //   if (exists(file + '.js')) {
      //     out.push(file + '.js');
      //     continue;
      //   }
      //
      // But this seems messy and non-explicit.
      // It also doesn't account for custom extensions.
      throw new Error(`File not found: ${string(file)}.`);
    }

    out.push(file);
  }

  return out;
}

function flatten(files, extensions, recurse = false) {
  assert(Array.isArray(files));
  assert(Array.isArray(extensions));
  assert(typeof recurse === 'boolean');

  for (const file of files)
    assert(typeof file === 'string');

  for (const ext of extensions) {
    assert(typeof ext === 'string');
    assert(ext.length > 0 && ext[0] === '.');
  }

  return walk(files, extensions, recurse, 0, []);
}

function walk(files, extensions, recurse, depth, out) {
  for (const file of files) {
    const stat = fs.statSync(file);

    if (stat.isDirectory()) {
      // Avoid symlink loops (diverges from mocha).
      if (fs.lstatSync(file).isSymbolicLink())
        continue;

      // Without the recurse option,
      // mocha delves one level deep.
      if (recurse || depth === 0)
        walk(readdir(file), extensions, recurse, depth + 1, out);

      continue;
    }

    // If a file was given to us explicity,
    // do not filter. The result of a glob is
    // considered explicit (mimic mocha behavior).
    if (depth === 0) {
      if (!stat.isFile()) {
        // Mocha throws with a nasty error
        // in this case. We can do better.
        throw new Error(`Not a regular file: ${string(file)}.`);
      }
      out.push(file);
      continue;
    }

    // Files only.
    if (!stat.isFile())
      continue;

    // No dotfiles.
    if (basename(file)[0] === '.')
      continue;

    // Only our specific extensions.
    if (extensions.length > 0) {
      const ext = extname(file);

      if (extensions.indexOf(ext) === -1)
        continue;
    }

    out.push(file);
  }

  return out;
}

function exclude(files, excludes) {
  assert(Array.isArray(files));
  assert(Array.isArray(excludes));

  return files.filter((name) => {
    return excludes.every((pattern) => {
      return !glob.minimatch(name, pattern);
    });
  });
}

function resolvify(files) {
  assert(Array.isArray(files));
  return files.map(file => resolve(cwd, file));
}

function getFiles(root, extensions, out = []) {
  assert(typeof root === 'string');
  assert(Array.isArray(extensions));
  assert(Array.isArray(out));

  root = resolve(cwd, root);

  for (const name of fs.readdirSync(root)) {
    if (name === '.git' || name === 'node_modules')
      continue;

    const file = join(root, name);
    const stat = fs.statSync(file);

    if (stat.isDirectory()) {
      // Avoid symlink loops (diverges from mocha).
      if (!fs.lstatSync(file).isSymbolicLink())
        getFiles(file, extensions, out);
      continue;
    }

    // Files only.
    if (!stat.isFile())
      continue;

    // No dotfiles.
    if (name[0] === '.')
      continue;

    // Only our specific extensions.
    if (extensions.length > 0) {
      const ext = extname(name);

      if (extensions.indexOf(ext) === -1)
        continue;
    }

    // Ignore everything in
    // our own lib and bin.
    if (file.startsWith(BIN)
        || file.startsWith(LIB)) {
      continue;
    }

    out.push(file);
  }

  return out;
}

function watchFiles(files, callback) {
  assert(Array.isArray(files));
  assert(typeof callback === 'function');

  const options = { interval: 100 };

  const cb = async (cur, prev) => {
    if (prev.mtime < cur.mtime) {
      try {
        await callback();
      } catch (e) {
        stderr.write(e.stack + '\n');
        exit(1);
      }
    }
  };

  for (const file of files)
    fs.watchFile(file, options, cb);
}

function spawn(file, args, shell = false) {
  const cp = require('child_process');

  const ps = cp.spawn(file, args, {
    cwd,
    env,
    detached: true,
    stdio: 'ignore',
    shell
  });

  ps.on('error', () => {});

  ps.unref();

  return ps;
}

function navigate(url, cmd) {
  assert(typeof url === 'string');
  assert(cmd == null || typeof cmd === 'string');

  // Any OS:
  if (cmd) {
    if (cmd.indexOf('%s') !== -1) {
      cmd = cmd.replace(/%s/g, url);
      return spawn(cmd, [], true);
    }

    return spawn(cmd, [url], true);
  }

  // Windows:
  // https://stackoverflow.com/questions/3739327
  if (process.platform === 'win32')
    return spawn('explorer', [url]);

  // OSX:
  // https://superuser.com/questions/85151
  if (process.platform === 'darwin')
    return spawn('open', [url]);

  // Unix:
  const name = env.BROWSER;

  if (!name)
    return spawn('xdg-open', [url]);

  if (/(?:chrome|chromium)/i.test(name))
    return spawn(name, [`--app=${url}`]);

  return spawn(name, [url]);
}

function findFile(files) {
  assert(Array.isArray(files));

  for (const file of files) {
    if (exists(file))
      return file;
  }

  return null;
}

function findChrome() {
  if (env.BMOCHA_CHROMIUM)
    return env.BMOCHA_CHROMIUM;

  if (env.BMOCHA_CHROME)
    return env.BMOCHA_CHROME;

  // See: https://github.com/karma-runner/karma-chrome-launcher
  if (process.platform === 'darwin') {
    return findFile([
      '/Applications/Chromium.app/Contents/MacOS/Chromium',
      '/Applications/Google Chrome.app/Contents/MacOS/Google Chrome'
    ]);
  }

  if (process.platform === 'win32') {
    // https://stackoverflow.com/questions/40674914
    const names = [
      '\\Chromium\\Application\\chromium.exe',
      '\\Chromium\\chromium.exe',
      '\\Google\\Chrome\\Application\\chrome.exe', // Windows 10
      '\\Google\\Application\\chrome.exe', // Windows 7
      '\\Google\\Chrome\\chrome.exe' // Windows XP/Vista
    ];

    const files = [];

    for (const name of names) {
      for (const dir of [env.LOCALAPPDATA,
                         env.PROGRAMFILES,
                         env['PROGRAMFILES(X86)']]) {
        if (!dir || dir.length === 0)
          continue;

        files.push(join(dir, name));
      }
    }

    return findFile(files);
  }

  if (!env.PATH)
    return null;

  const files = [];

  for (const name of ['chromium',
                      'google-chrome',
                      'google-chrome-stable']) {
    for (const dir of env.PATH.split(':')) {
      if (dir.length === 0)
        continue;

      files.push(join(dir, name));
    }
  }

  return findFile(files);
}

function bindExit(handler) {
  assert(typeof handler === 'function');

  const onSighup = () => exit(1 | 0x80);
  const onSigint = () => exit(2 | 0x80);
  const onSigterm = () => exit(15 | 0x80);

  const onError = (err) => {
    if (err && err.stack)
      err = err.stack;

    stderr.write(err + '\n');
    exit(1);
  };

  process.once('exit', handler);

  if (process.listenerCount('SIGHUP') === 0)
    process.once('SIGHUP', onSighup);

  if (process.listenerCount('SIGINT') === 0)
    process.once('SIGINT', onSigint);

  if (process.listenerCount('SIGTERM') === 0)
    process.once('SIGTERM', onSigterm);

  if (process.listenerCount('uncaughtException') === 0)
    process.once('uncaughtException', onError);

  if (process.listenerCount('unhandledRejection') === 0)
    process.once('unhandledRejection', onError);

  process.on('newListener', (name) => {
    switch (name) {
      case 'SIGHUP':
        process.removeListener(name, onSighup);
        break;
      case 'SIGINT':
        process.removeListener(name, onSigint);
        break;
      case 'SIGTERM':
        process.removeListener(name, onSigterm);
        break;
      case 'uncaughtException':
        process.removeListener(name, onError);
        break;
      case 'unhandledRejection':
        process.removeListener(name, onError);
        break;
    }
  });
}

function runHeadless(url, chrome, extra = []) {
  assert(typeof url === 'string');
  assert(chrome == null || typeof chrome === 'string');
  assert(Array.isArray(extra));

  const cp = require('child_process');

  const file = chrome || findChrome();

  if (!file)
    throw new Error('Could not find chrome binary.');

  const port = 1000 + Math.floor(Math.random() * (0x10000 - 1000));

  const args = [
    '--headless',
    '--disable-gpu',
    `--remote-debugging-port=${port}`,
    ...extra,
    url
  ];

  let output = '';

  const onData = (data) => {
    if (output.length > (1 << 20))
      output = '';
    output += data;
  };

  const onError = (err) => {
    if (err.code === 'ENOENT')
      stderr.write(`Chrome not found: ${err.path}.\n`);
    else
      stderr.write(err.stack + '\n');
    exit(1);
  };

  const onExit = (code, signal) => {
    code >>>= 0;

    stderr.write('Chrome exited unexpectedly ');
    stderr.write(`(code=${code}, signal=${signal}).\n`);

    if (output.length > 0) {
      stderr.write('\n');
      stderr.write(output);
      stderr.write('\n');
    }

    if (code === 0)
      code = 1;

    exit(code);
  };

  const ps = cp.spawn(file, args, {
    cwd,
    env,
    detached: false,
    stdio: ['ignore', 'pipe', 'pipe'],
    shell: false
  });

  ps.stdout.unref();
  ps.stdout.setEncoding('utf8');
  ps.stdout.on('error', () => {});
  ps.stdout.on('data', onData);

  ps.stderr.unref();
  ps.stderr.setEncoding('utf8');
  ps.stderr.on('error', () => {});
  ps.stderr.on('data', onData);

  ps.unref();
  ps.on('error', onError);
  ps.on('exit', onExit);

  bindExit(() => {
    ps.removeListener('exit', onExit);
    ps.kill('SIGTERM');
  });

  return [[file, ...args], ps];
}

function getArgs(argv) {
  assert(Array.isArray(argv));

  const args = [];

  for (let i = 0; i < argv.length; i++) {
    const arg = argv[i];

    assert(typeof arg === 'string');

    if (arg.startsWith('--')) {
      // e.g. --opt
      const index = arg.indexOf('=');
      if (index !== -1) {
        // e.g. --opt=val
        args.push(arg.substring(0, index));
        args.push(arg.substring(index + 1));
      } else {
        args.push(arg);
      }
    } else if (arg.startsWith('-')) {
      if (arg.length > 2) {
        // e.g. -abc
        for (let j = 1; j < arg.length; j++)
          args.push(`-${arg.charAt(j)}`);
      } else {
        // e.g. -a
        args.push(arg);
      }
    } else {
      // e.g. foo
      args.push(arg);
    }
  }

  const out = [];

  let opts = null;

  if (exists(DEFAULT_OPTS))
    opts = DEFAULT_OPTS;

  for (let i = 0; i < args.length; i++) {
    switch (args[i]) {
      case '--opts': {
        if (i + 1 < args.length)
          opts = args[i + 1];
        i += 1;
        break;
      }
      case '--no-opts': {
        opts = null;
        break;
      }
    }
  }

  if (opts != null) {
    const text = fs.readFileSync(opts, 'utf8');
    const args = text.replace(/^#.*$/gm, '')
                     .replace(/\\\s/g, '%20')
                     .split(/\s/);

    for (const arg of args) {
      if (arg.length === 0)
        continue;

      out.push(arg.replace(/%20/g, ' '));
    }
  }

  out.push(...args);

  return out;
}

function parseArgs() {
  const options = {
    __proto__: null,
    asyncOnly: false,
    bail: false,
    cert: null,
    checkLeaks: false,
    chrome: null,
    cmd: '',
    colors: Boolean(stdout.isTTY),
    console: false,
    diff: true,
    excludes: [],
    exit: false,
    extensions: [],
    fgrep: '',
    forbidOnly: false,
    forbidPending: false,
    fileArgs: [],
    files: [],
    fullTrace: false,
    global: true,
    globals: [],
    grep: null,
    headless: false,
    inlineDiffs: false,
    invert: false,
    key: null,
    listen: false,
    open: false,
    port: -1,
    recurse: false,
    reporter: env.BMOCHA_REPORTER || 'spec',
    reporterOptions: Object.create(null),
    requires: [],
    retries: 0,
    slow: 75,
    ssl: false,
    sslIgnore: false,
    sort: false,
    stream: stdout,
    timeout: 2000,
    timeouts: true,
    uncaught: false,
    watch: false,
    windows: process.platform === 'win32'
  };

  let {
    excludes,
    extensions,
    fileArgs,
    files,
    reporterOptions
  } = options;

  const args = getArgs(argv.slice(2));

  for (let i = 0; i < args.length; i++) {
    const arg = args[i];

    let next = '';

    if (i + 1 < args.length)
      next = args[i + 1];

    switch (arg) {
      case '-A':
      case '--async-only': {
        options.asyncOnly = true;
        break;
      }

      case '--allow-uncaught': {
        options.uncaught = true;
        break;
      }

      case '-b':
      case '--bail': {
        options.bail = true;
        break;
      }

      case '-c':
      case '--colors': {
        options.colors = true;
        break;
      }

      case '-C':
      case '--no-colors': {
        options.colors = false;
        break;
      }

      case '--config': {
        throw new Error('Config support is unimplemented.');
      }

      case '--check-leaks': {
        options.checkLeaks = true;
        break;
      }

      case '--chrome': {
        if (!next)
          throw new Error(`Invalid option for ${arg}.`);

        options.listen = true;
        options.open = true;
        options.headless = true;
        options.chrome = next;

        i += 1;

        break;
      }

      case '--diff': {
        options.diff = true;
        break;
      }

      case '--exclude': {
        if (!next)
          throw new Error(`Invalid option for ${arg}.`);

        excludes.push(next);

        i += 1;

        break;
      }

      case '--exit': {
        options.exit = true;
        break;
      }

      case '--extension':
      case '--watch-extensions': {
        if (!next)
          throw new Error(`Invalid option for ${arg}.`);

        for (let ext of next.split(',')) {
          if (ext.length === 0 || ext === '.')
            throw new Error(`Invalid extension for ${arg}.`);

          if (ext[0] !== '.')
            ext = '.' + ext;

          extensions.push(ext);
        }

        i += 1;

        break;
      }

      case '-f':
      case '--fgrep': {
        if (!next)
          throw new Error(`Invalid option for ${arg}.`);

        options.fgrep = next;

        i += 1;

        break;
      }

      case '--file': {
        if (!next)
          throw new Error(`Invalid option for ${arg}.`);

        fileArgs.push(next);

        i += 1;

        break;
      }

      case '--forbid-only': {
        options.forbidOnly = true;
        break;
      }

      case '--forbid-pending': {
        options.forbidPending = true;
        break;
      }

      case '--full-trace': {
        options.fullTrace = true;
        break;
      }

      case '-g':
      case '--grep': {
        if (!next)
          throw new Error(`Invalid option for ${arg}.`);

        options.grep = new RegExp(next);

        i += 1;

        break;
      }

      case '-G':
      case '--growl': {
        throw new Error('Growl support is unimplemented.');
      }

      case '--global':
      case '--globals': {
        options.globals = next.split(',');

        if (options.globals.indexOf('') !== -1)
          throw new Error(`Invalid option for ${arg}.`);

        i += 1;

        break;
      }

      case '-H':
      case '--headless': {
        options.listen = true;
        options.open = true;
        options.headless = true;
        break;
      }

      case '-h':
      case '--help': {
        stdout.write(HELP + '\n');
        exit(0);
        break;
      }

      case '-i':
      case '--invert': {
        options.invert = true;
        break;
      }

      case '--inline-diffs': {
        options.inlineDiffs = true;
        break;
      }

      case '--interfaces': {
        stdout.write(INTERFACES + '\n');
        exit(0);
        break;
      }

      case '-l':
      case '--listen': {
        options.listen = true;
        break;
      }

      case '-m':
      case '--cmd': {
        if (!next)
          throw new Error(`Invalid option for ${arg}.`);

        options.listen = true;
        options.open = true;
        options.cmd = next;

        i += 1;

        break;
      }

      case '--no-diff': {
        options.diff = false;
        break;
      }

      case '--no-opts': {
        break;
      }

      case '--no-timeouts': {
        options.timeouts = false;
        break;
      }

      case '-o':
      case '--open': {
        options.listen = true;
        options.open = true;
        break;
      }

      case '-O':
      case '--reporter-option':
      case '--reporter-options': {
        if (!next)
          throw new Error(`Invalid option for: ${arg}.`);

        for (const opt of next.split(',')) {
          const parts = opt.split('=');

          if (parts.length > 2 || parts.length === 0)
            throw new Error(`Invalid reporter option ${opt}.`);

          if (parts.length === 2)
            reporterOptions[parts[0]] = parts[1];
          else
            reporterOptions[parts[0]] = true;
        }

        i += 1;

        break;
      }

      case '--opts': {
        if (!next)
          throw new Error(`Invalid option for ${arg}.`);

        i += 1;

        break;
      }

      case '--package': {
        throw new Error('Package support is unimplemented.');
      }

      case '-p':
      case '--port': {
        options.port = next >>> 0;

        if (!next || options.port > 0xffff)
          throw new Error(`Invalid option for ${arg}.`);

        options.listen = true;
        i += 1;

        break;
      }

      case '-R':
      case '--reporter': {
        if (!next)
          throw new Error(`Invalid option for: ${arg}.`);

        options.reporter = next;

        i += 1;

        break;
      }

      case '-r':
      case '--require': {
        if (!next)
          throw new Error(`Invalid option for ${arg}.`);

        if (exists(next) || exists(`${next}.js`))
          next = resolve(cwd, next);

        options.requires.push(next);
        i += 1;

        break;
      }

      case '--recursive': {
        options.recurse = true;
        break;
      }

      case '--reporters': {
        stdout.write(REPORTERS + '\n');
        exit(0);
        break;
      }

      case '--retries': {
        options.retries = next >>> 0;
        i += 1;
        break;
      }

      case '-s':
      case '--slow': {
        options.slow = next >>> 0;
        i += 1;
        break;
      }

      case '-S':
      case '--sort': {
        options.sort = true;
        break;
      }

      case '--ssl': {
        options.listen = true;
        options.ssl = true;
        break;
      }

      case '--cert':
      case '--ssl-cert': {
        if (!next)
          throw new Error(`Invalid option for ${arg}.`);

        options.listen = true;
        options.ssl = true;
        options.cert = fs.readFileSync(next);

        i += 1;

        break;
      }

      case '--ssl-ignore': {
        options.headless = true;
        options.open = true;
        options.listen = true;
        options.ssl = true;
        options.sslIgnore = true;
        break;
      }

      case '--key':
      case '--ssl-key': {
        if (!next)
          throw new Error(`Invalid option for ${arg}.`);

        options.listen = true;
        options.ssl = true;
        options.key = fs.readFileSync(next);

        i += 1;

        break;
      }

      case '-t':
      case '--timeout': {
        options.timeout = next >>> 0;
        i += 1;
        break;
      }

      case '-u':
      case '--ui': {
        if (next !== 'bdd')
          throw new Error(`Invalid interface: ${next}.`);
        i += 1;
        break;
      }

      case '-V':
      case '--version': {
        stdout.write(VERSION + '\n');
        exit(0);
        break;
      }

      case '-w':
      case '--watch': {
        options.watch = true;
        break;
      }

      case '-z':
      case '--console': {
        options.console = true;
        break;
      }

      default: {
        if (arg.length === 0 || arg[0] === '-')
          throw new Error(`Invalid argument: ${arg}.`);

        if (i === 0 && arg === 'init')
          throw new Error('"init" is unimplemented.');

        options.files.push(arg);

        break;
      }
    }
  }

  if (options.listen) {
    if (options.port === -1)
      options.port = options.open ? 0 : 8080;
  }

  if (options.ssl) {
    if (!options.key)
      throw new Error('SSL specified with no provided key.');

    if (!options.cert)
      throw new Error('SSL specified with no provided cert.');
  }

  if (files.length === 0) {
    if (exists('test'))
      files.push('test');
    else if (exists('test.js'))
      files.push('test.js');
  }

  if (extensions.length === 0)
    extensions.push('.js');

  files = globify(files);
  files = flatten(files, extensions, options.recurse);
  files = exclude(files, excludes);
  files = resolvify(files);

  if (options.sort)
    files.sort();

  // Note that file args aren't processed
  // in any extra way other than resolving
  // them against the current working dir.
  fileArgs = resolvify(fileArgs);

  // Quick and dirty check for file args.
  for (const file of fileArgs) {
    if (!exists(file))
      throw new Error(`File not found: ${string(file)}.`);
  }

  // Final step: file args run first.
  files = fileArgs.concat(files);

  if (files.length === 0)
    throw new Error('No test files found.');

  options.fileArgs = fileArgs;
  options.files = files;

  if (typeof reporterOptions.output === 'string') {
    const {output} = reporterOptions;
    const path = output.replace(/^~\//, `${os.homedir()}/`);
    const file = resolve(cwd, path);
    const dir = dirname(file);

    if (version >= 0x0a0c00)  {
      // Recursive mkdir was added in node v10.12.0.
      fs.mkdirSync(dir, { mode: 0o755, recursive: true });
    }

    const stream = fs.createWriteStream(file);

    stream.on('error', (err) => {
      if (err.code === 'ERR_STREAM_WRITE_AFTER_END')
        return;

      if (err.message === 'write after end')
        return;

      stderr.write(err.stack + '\n');
      exit(1);
    });

    options.stream = stream;
    options.colors = false;
  }

  return options;
}

/*
 * Error Handling
 */

function catcher(reject) {
  const onError = (error) => {
    const err = errorify(error);

    err.uncaught = true;
    err.exception = true;

    reject(err);
  };

  const onRejection = (reason, promise) => {
    const err = errorify(reason);

    err.uncaught = true;
    err.rejection = true;

    reject(err);
  };

  const onMultiple = (type, promise, value) => {
    const kind = inspect.type(value);
    const err = new Error(`Multiple ${type}s detected for ${kind}.`);

    err.uncaught = true;
    err.multiple = true;
    err.display = true;
    err.value = value;

    reject(err);
  };

  on('uncaughtException', onError);
  on('unhandledRejection', onRejection);
  on('multipleResolves', onMultiple);

  return () => {
    off('uncaughtException', onError);
    off('unhandledRejection', onRejection);
    off('multipleResolves', onMultiple);
  };
}

/*
 * Main
 */

(async () => {
  let options;

  try {
    options = parseArgs();
  } catch (e) {
    if (e.code === 'ENOENT') {
      const file = relative(cwd, resolve(cwd, e.path));
      stderr.write(`File not found: ${string(file)}.\n`);
      return 1;
    }
    stderr.write(e.message + '\n');
    return 1;
  }

  if (options.listen) {
    const Server = require('../lib/server');
    const server = new Server(options);
    const addr = await server.listen(options.port, 'localhost');
    const protocol = options.ssl ? 'https' : 'http';
    const url = `${protocol}://localhost:${addr.port}/`;
    const chromeOptions = [];

    server.on('error', (err) => {
      stderr.write('\n');
      stderr.write('Server Error:\n');
      stderr.write(err.stack + '\n');
    });

    if (options.ssl && options.sslIgnore)
      chromeOptions.push('--ignore-certificate-errors');

    if (options.headless) {
      runHeadless(url, options.chrome, chromeOptions);
      return -1;
    }

    stdout.write(`Server listening at: ${url}\n`);

    if (options.open)
      navigate(url, options.cmd);

    return -1;
  }

  env.BMOCHA = '1';
  env.NODE_TEST = '1';
  env.BMOCHA_REPORTER = options.reporter;

  const mocha = new Mocha(options);

  if (!options.uncaught)
    mocha.catcher = catcher;

  mocha.exit = exit;

  module.paths.push(cwd, join(cwd, 'node_modules'));

  for (const file of options.requires)
    require(file);

  const funcs = options.files.map(file => wrap(file));
  const code = await mocha.run(funcs);

  if (options.watch) {
    const files = getFiles(cwd, options.extensions);

    stdout.write('\x1b[?25l');

    bindExit(() => {
      stdout.write('\x1b[?25h');
    });

    watchFiles(files, async () => {
      for (const file of files)
        delete require.cache[file];

      await mocha.abort();

      stdout.write('\n');

      await mocha.run(funcs);
    });

    return -1;
  }

  if (options.exit)
    exit(code);

  return code;
})().then((code) => {
  if (code !== -1) {
    process.exitCode = code;
    on('exit', () => exit(code));
  }
}).catch((err) => {
  stderr.write(err.stack + '\n');
  exit(1);
});
