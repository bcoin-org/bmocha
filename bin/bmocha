#!/usr/bin/env node

/* eslint no-control-regex: "off" */

'use strict';

const assert = require('assert');
const Path = require('path');

const {
  Date,
  clearTimeout,
  Error,
  Math,
  process,
  Promise,
  setTimeout,
  String
} = global;

const cwd = process.cwd();
const {argv, stdout, stderr, exit} = process;

/*
 * Constants
 */

const defaults = {
  timeout: 2000,
  befores: [],
  afters: [],
  beforeEaches: [],
  afterEaches: []
};

/**
 * Mocha
 */

class Mocha {
  constructor(files) {
    assert(Array.isArray(files));

    this.files = files;
    this.stdout = stdout;
    this.colors = Boolean(stdout.isTTY);
    this.bail = false;
    this.grep = null;
    this.fgrep = null;
    this.invert = false;
    this.errors = [];
    this.passing = 0;
    this.failing = 0;
  }

  matches(name) {
    assert(typeof name === 'string');

    let ret = false;

    if (this.grep)
      ret = this.grep.test(name);
    else if (this.fgrep)
      ret = name.indexOf(this.fgrep) !== -1;
    else
      ret = true;

    if (this.invert)
      ret = !ret;

    return ret;
  }

  log(str, depth) {
    if (!this.colors)
      str = str.replace(/\x1b\[[^m]*?m/g, '');

    str = indent(str, depth);

    this.stdout.write(str + '\n');
  }

  error(id, desc, name, err) {
    if (err == null || typeof err !== 'object')
      err = String(err);

    if (typeof err === 'string')
      err = new Error(err);

    assert((id >>> 0) === id);
    assert(typeof desc === 'string');
    assert(typeof name === 'string');
    assert(err && typeof err === 'object');

    const stack = formatStack(err.stack);

    this.log(`${id}) ${desc}`, 1);
    this.log(` ${name}:`, 3);
    this.log('');
    this.log(`\x1b[31m${err.name}: ${err.message}\x1b[m`, 3);

    if (err.code === 'ERR_ASSERTION') {
      this.log('\x1b[32m+ expected\x1b[m \x1b[31m- actual\x1b[m', 3);
      this.log('');
      this.log(`\x1b[31m-${err.actual}\x1b[m`, 3);
      this.log(`\x1b[32m+${err.expected}\x1b[m`, 3);
    }

    this.log('');
    this.log(`\x1b[90m${stack}\x1b[m`, 3);
    this.log('');
  }

  async run() {
    const start = Date.now();

    for (const file of this.files) {
      const suite = new Suite(this, file);
      await suite.run();
    }

    const elapsed = Math.ceil((Date.now() - start) / 1000);
    const passed = `\x1b[32m${this.passing} passing\x1b[m`;
    const time = `\x1b[90m(${elapsed}s)\x1b[m`;

    this.log('');
    this.log(`${passed} ${time}`, 1);

    if (this.failing > 0)
      this.log(`\x1b[31m${this.failing} failing\x1b[m`, 1);

    this.log('');

    for (const [i, [desc, name, err]] of this.errors.entries())
      this.error(i + 1, desc, name, err);
  }
}

/**
 * Suite
 */

class Suite {
  constructor(mocha, file) {
    assert(mocha instanceof Mocha);
    assert(typeof file === 'string');

    this.mocha = mocha;
    this.file = file;
    this.current = null;
    this.descs = [];
    this.depth = 1;
    this.init();
  }

  describe(name, func) {
    const desc = new Desc(this, name, func);

    this.descs.push(desc);

    desc.init();
  }

  init() {
    const name = Path.resolve(cwd, this.file);

    global.describe = this.describe.bind(this);

    if (require.cache)
      delete require.cache[name];

    try {
      require(name);
    } catch (e) {
      if (e.code === 'MODULE_NOT_FOUND')
        throw new Error(`Could not find ${this.file}.`);

      throw e;
    }
  }

  async run() {
    global.describe = this.describe.bind(this);

    for (const desc of this.descs)
      await desc.run();
  }
}

/**
 * Desc
 */

class Desc {
  constructor(suite, name, func) {
    assert(suite instanceof Suite);
    assert(typeof name === 'string');
    assert(typeof func === 'function');

    const parent = suite.current || defaults;

    this.mocha = suite.mocha;
    this.suite = suite;
    this.parent = suite.current;
    this.name = name;
    this.func = func;
    this.depth = suite.depth;
    this.timeout = parent.timeout;
    this.befores = parent.befores.slice();
    this.afters = parent.afters.slice();
    this.beforeEaches = parent.beforeEaches.slice();
    this.afterEaches = parent.afterEaches.slice();
    this.tests = [];

    this.api = {
      timeout: (ms) => {
        this.timeout = ms >>> 0;
      }
    };
  }

  log(str) {
    this.mocha.log(str, this.depth);
  }

  push(name, err) {
    assert(typeof name === 'string');

    if (this.mocha.bail)
      throw err;

    this.mocha.errors.push([this.name, name, err]);
  }

  get id() {
    return this.mocha.errors.length;
  }

  pass() {
    this.mocha.passing += 1;
  }

  fail() {
    this.mocha.failing += 1;
  }

  before(func) {
    assert(typeof func === 'function');
    this.befores.push(func);
  }

  after(func) {
    assert(typeof func === 'function');
    this.afters.push(func);
  }

  beforeEach(func) {
    assert(typeof func === 'function');
    this.beforeEaches.push(func);
  }

  afterEach(func) {
    assert(typeof func === 'function');
    this.afterEaches.push(func);
  }

  it(name, func) {
    assert(typeof name === 'string');
    assert(typeof func === 'function');
    this.tests.push([name.slice(0, 100), func]);
  }

  init() {
    const current = this.suite.current;
    const before = global.before;
    const after = global.after;
    const beforeEach = global.beforeEach;
    const afterEach = global.afterEach;
    const it = global.it;

    global.before = this.before.bind(this);
    global.after = this.after.bind(this);
    global.beforeEach = this.beforeEach.bind(this);
    global.afterEach = this.afterEach.bind(this);
    global.it = this.it.bind(this);

    this.suite.depth += 1;
    this.suite.current = this;

    try {
      this.func.call(this.api);
    } catch (e) {
      this.push(this.name, e);
    }

    this.suite.current = current;
    this.suite.depth -= 1;

    global.before = before;
    global.after = after;
    global.beforeEach = beforeEach;
    global.afterEach = afterEach;
    global.it = it;
  }

  async run() {
    let failed = false;

    this.log('');
    this.log(`${this.name}`);

    for (const before of this.befores) {
      try {
        await this.runTest(before);
      } catch (e) {
        if (!failed) {
          this.push('before hook', e);
          failed = true;
        }
      }
    }

    for (const [name, func] of this.tests) {
      if (!this.mocha.matches(name))
        continue;

      const start = Date.now();

      let failed = false;

      for (const before of this.beforeEaches) {
        try {
          await this.runTest(before);
        } catch (e) {
          if (!failed) {
            this.push(name, e);
            failed = true;
          }
        }
      }

      try {
        await this.runTest(func);
      } catch (e) {
        if (!failed) {
          this.push(name, e);
          failed = true;
        }
      }

      for (const after of this.afterEaches) {
        try {
          await this.runTest(after);
        } catch (e) {
          if (!failed) {
            this.push(name, e);
            failed = true;
          }
        }
      }

      if (failed) {
        this.log(`  \x1b[31m${this.id}) ${name}\x1b[m `);
        this.fail();
        continue;
      }

      const elapsed = Date.now() - start;

      let suffix = '';

      if (elapsed >= 100)
        suffix = `\x1b[31m (${elapsed}ms)\x1b[m`;
      else if (elapsed >= 40)
        suffix = `\x1b[33m (${elapsed}ms)\x1b[m`;

      this.log(`  \x1b[32mâœ“\x1b[m \x1b[90m${name}\x1b[m${suffix}`);
      this.pass();
    }

    for (const after of this.afters) {
      try {
        await this.runTest(after);
      } catch (e) {
        if (!failed) {
          this.push('after hook', e);
          failed = true;
        }
      }
    }
  }

  async runTest(func) {
    assert(typeof func === 'function');

    return new Promise((resolve, reject) => {
      let timeout = this.timeout;
      let called = false;
      let timer = null;

      const ctx = {
        timeout: (ms) => {
          timeout = ms >>> 0;
        }
      };

      const cleanup = () => {
        if (timer != null) {
          clearTimeout(timer);
          timer = null;
        }
      };

      if (func.length > 0) {
        const cb = (err, result) => {
          cleanup();

          if (err) {
            reject(err);
            return;
          }

          if (!called) {
            called = true;
            resolve(result);
          }
        };

        try {
          func.call(ctx, cb);
        } catch (e) {
          called = true;
          reject(e);
          return;
        }
      } else {
        let promise;

        try {
          promise = func.call(ctx);
        } catch (e) {
          called = true;
          reject(e);
          return;
        }

        if (!(promise instanceof Promise)) {
          called = true;
          resolve(promise);
          return;
        }

        promise.then((result) => {
          cleanup();
          if (!called) {
            called = true;
            resolve(result);
          }
        }).catch((err) => {
          cleanup();
          if (!called) {
            called = true;
            reject(err);
          }
        });
      }

      if (timeout !== 0) {
        timer = setTimeout(() => {
          timer = null;
          if (!called) {
            called = true;
            reject(new Error(`Timeout of ${timeout}ms exceeded.`));
          }
        }, timeout);
      }
    });
  }
}

/*
 * Helpers
 */

function indent(str, depth) {
  if (depth == null)
    depth = 0;

  assert(typeof str === 'string');
  assert((depth >>> 0) === depth);

  if (depth === 0)
    return str;

  let spaces = '';

  for (let i = 0; i < depth * 2; i++)
    spaces += ' ';

  return str.replace(/^/gm, spaces);
}

function formatStack(stack) {
  let str = String(stack);

  const index = str.indexOf('\n    at ');

  if (index !== -1)
    str = str.substring(index + 1);

  return str.replace(/^[ \t]+/gm, '');
}

/*
 * Main
 */

process.on('unhandledRejection', (err, promise) => {
  stderr.write('Unhandled rejection:\n');
  stderr.write('\n');
  if (err && err.stack)
    err = String(err.stack);
  stderr.write(err + '\n');
  exit(1);
});

(async () => {
  const files = [];
  const excludes = [];

  let colors = null;
  let sort = false;
  let bail = false;
  let grep = null;
  let fgrep = null;
  let invert = false;
  let doExit = false;

  for (let i = 2; i < argv.length; i++) {
    const arg = argv[i];

    let next = '';

    if (i + 1 < argv.length)
      next = argv[i + 1];

    switch (arg) {
      case '-c':
      case '--colors':
        colors = true;
        break;
      case '-C':
      case '--no-colors':
        colors = false;
        break;
      case '-O':
      case '--reporter-options':
        i += 1;
        break;
      case '-R':
      case '--reporter':
        if (next !== 'spec') {
          stderr.write(`Invalid reporter: ${next}.\n`);
          exit(1);
        }
        i += 1;
        break;
      case '-S':
      case '--sort':
        sort = true;
        break;
      case '-b':
      case '--bail':
        bail = true;
        break;
      case '-g':
      case '--grep':
        grep = new RegExp(next);
        i += 1;
        break;
      case '-f':
      case '--fgrep':
        fgrep = next;
        i += 1;
        break;
      case '-i':
      case '--invert':
        invert = true;
        break;
      case '-r':
      case '--require':
        if (next[0] === '.')
          next = Path.resolve(cwd, next);
        require(next);
        i += 1;
        break;
      case '-s':
      case '--slow':
        i += 1;
        break;
      case '-t':
      case '--timeout':
        defaults.timeout = next >>> 0;
        i += 1;
        break;
      case '--no-timeouts':
        defaults.timeout = 0;
        break;
      case '--exit':
        doExit = true;
        break;
      case '--file':
        files.unshift(next);
        i += 1;
        break;
      case '--exclude':
        excludes.push(Path.basename(next));
        i += 1;
        break;
      default:
        if (arg.length === 0 || arg[0] === '-') {
          stderr.write(`Invalid option: ${arg}.\n`);
          exit(1);
        }
        if (excludes.indexOf(Path.basename(arg)) === -1)
          files.push(arg);
        break;
    }
  }

  if (sort)
    files.sort();

  const mocha = new Mocha(files);

  if (colors != null)
    mocha.colors = colors;

  mocha.bail = bail;
  mocha.grep = grep;
  mocha.fgrep = fgrep;
  mocha.invert = invert;

  await mocha.run();

  if (mocha.failing > 0)
    exit(mocha.failing);

  if (doExit)
    exit(0);
})().catch((err) => {
  stderr.write('An error occurred outside of the test suite:\n');
  stderr.write('\n');
  if (err && err.stack)
    err = String(err.stack);
  stderr.write(err + '\n');
  exit(1);
});
