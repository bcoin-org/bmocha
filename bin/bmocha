#!/usr/bin/env node

/*!
 * bmocha - minimal mocha implementation
 * Copyright (c) 2018, Christopher Jeffrey (MIT License).
 * https://github.com/chjj/bmocha
 */

/* eslint no-control-regex: "off" */
/* eslint max-len: "off" */

'use strict';

const assert = require('assert');
const fs = require('fs');
const path = require('path');

const {
  basename,
  extname,
  join,
  resolve
} = path;

const {
  Array,
  Boolean,
  Date,
  clearTimeout,
  Error,
  Math,
  Number,
  process,
  Promise,
  RegExp,
  setTimeout,
  String
} = global;

const cwd = process.cwd();
const {argv, stdout, stderr, exit} = process;

/*
 * Constants
 */

const VERSION = '0.1.0';

const HELP = `
  Usage: bmocha [options] [files]

  Options:

    -V, --version                           output the version number
    -c, --colors                            force enabling of colors
    -C, --no-colors                         force disabling of colors
    -O, --reporter-options <k=v,k2=v2,...>  reporter-specific options
    -R, --reporter <name>                   specify the reporter to use (default: spec)
    -S, --sort                              sort test files
    -b, --bail                              bail after first test failure
    -g, --grep <pattern>                    only run tests matching <pattern>
    -f, --fgrep <string>                    only run tests containing <string>
    -i, --invert                            inverts --grep and --fgrep matches
    -r, --require <name>                    require the given module
    -s, --slow <ms>                         "slow" test threshold in milliseconds [75]
    -t, --timeout <ms>                      set test-case timeout in milliseconds [2000]
    --exit                                  force shutdown of the event loop after test run: bmocha will call process.exit
    --no-timeouts                           disables timeouts
    --recursive                             include sub directories
    --retries <times>                       set numbers of time to retry a failed test case
    --file <file>                           include a file to be ran during the suite
    --exclude <file>                        a file or glob pattern to ignore
    -h, --help                              output usage information
`;

const nullStream = {
  write: _ => true,
  isTTY: true
};

/**
 * Mocha
 */

class Mocha {
  constructor(stream = nullStream) {
    assert(stream && typeof stream.write === 'function');

    this.stream = stream;
    this.colors = Boolean(stream.isTTY);
    this.bail = false;
    this.grep = null;
    this.fgrep = null;
    this.invert = false;
    this.depth = -1;
    this.slow = 75;
    this.timeout = 2000;
    this.timeouts = true;
    this.retries = 0;
    this.beforeEaches = [];
    this.afterEaches = [];
    this.errors = [];
    this.passing = 0;
    this.failing = 0;
  }

  matches(name) {
    assert(typeof name === 'string');

    let ret = !this.invert;

    if (this.grep)
      ret = this.grep.test(name);
    else if (this.fgrep)
      ret = name.indexOf(this.fgrep) !== -1;

    if (this.invert)
      ret = !ret;

    return ret;
  }

  log(str, depth) {
    assert(typeof str === 'string');

    if (!this.colors)
      str = str.replace(/\x1b\[[^m]*?m/g, '');

    str = indent(str, depth);

    this.stream.write(str + '\n');
  }

  error(id, desc, name, err) {
    if (err == null || typeof err !== 'object')
      err = String(err);

    if (typeof err === 'string')
      err = new Error(err);

    assert((id >>> 0) === id);
    assert(typeof desc === 'string');
    assert(typeof name === 'string');
    assert(err && typeof err === 'object');

    const stack = formatStack(err.stack);

    if (desc) {
      this.log(`${id}) ${desc}`, 1);
      this.log(`${name}:`, 3);
    } else {
      this.log(`${id}) ${name}:`, 1);
    }

    this.log('');
    this.log(`\x1b[31m${err.name}: ${err.message}\x1b[m`, 3);

    if (err.code === 'ERR_ASSERTION') {
      this.log('\x1b[32m+ expected\x1b[m \x1b[31m- actual\x1b[m', 3);
      this.log('');
      this.log(`\x1b[31m-${err.actual}\x1b[m`, 3);
      this.log(`\x1b[32m+${err.expected}\x1b[m`, 3);
    }

    this.log('');
    this.log(`\x1b[90m${stack}\x1b[m`, 3);
    this.log('');
  }

  async run(funcs) {
    assert(Array.isArray(funcs));

    const start = Date.now();

    this.errors = [];
    this.passing = 0;
    this.failing = 0;

    for (const func of funcs) {
      const suite = Suite.from(this, func);

      if (!await suite.run())
        break;
    }

    const elapsed = Math.ceil((Date.now() - start) / 1000);
    const passed = `\x1b[32m${this.passing} passing\x1b[m`;
    const time = `\x1b[90m(${elapsed}s)\x1b[m`;

    this.log('');
    this.log(`${passed} ${time}`, 1);

    if (this.failing > 0)
      this.log(`\x1b[31m${this.failing} failing\x1b[m`, 1);

    this.log('');

    for (const [i, [desc, name, err]] of this.errors.entries())
      this.error(i + 1, desc, name, err);

    return Math.min(this.failing, 255);
  }
}

/**
 * Suite
 */

class Suite {
  constructor(mocha, parent, name, func) {
    assert(mocha instanceof Mocha);
    assert((parent instanceof Mocha)
        || (parent instanceof Suite));
    assert(typeof name === 'string');
    assert(typeof func === 'function');

    this.mocha = mocha;
    this.name = name;
    this.func = func;
    this.depth = parent.depth + 1;
    this.timeout = parent.timeout;
    this.timeouts = parent.timeouts;
    this.retries = parent.retries;
    this.befores = [];
    this.afters = [];
    this.beforeEaches = parent.beforeEaches.slice();
    this.afterEaches = parent.afterEaches.slice();
    this.tests = [];
    this.suites = [];

    this.api = {
      timeout: (ms) => {
        this.timeout = ms >>> 0;
      }
    };

    this.init();
  }

  log(str) {
    this.mocha.log(str, this.depth);
  }

  describe(name, func) {
    const {mocha} = this;
    const suite = new Suite(mocha, this, name, func);

    this.suites.push(suite);
  }

  before(func) {
    assert(typeof func === 'function');
    this.befores.push(func);
  }

  after(func) {
    assert(typeof func === 'function');
    this.afters.push(func);
  }

  beforeEach(func) {
    assert(typeof func === 'function');
    this.beforeEaches.push(func);
  }

  afterEach(func) {
    assert(typeof func === 'function');
    this.afterEaches.push(func);
  }

  it(name, func) {
    assert(typeof name === 'string');
    assert(typeof func === 'function');

    if (this.mocha.matches(name))
      this.tests.push([name.substring(0, 300), func]);
  }

  init() {
    const describe = global.describe;
    const before = global.before;
    const after = global.after;
    const beforeEach = global.beforeEach;
    const afterEach = global.afterEach;
    const it = global.it;

    global.describe = this.describe.bind(this);
    global.before = this.before.bind(this);
    global.after = this.after.bind(this);
    global.beforeEach = this.beforeEach.bind(this);
    global.afterEach = this.afterEach.bind(this);
    global.it = this.it.bind(this);

    try {
      this.func.call(this.api);
    } finally {
      global.describe = describe;
      global.before = before;
      global.after = after;
      global.beforeEach = beforeEach;
      global.afterEach = afterEach;
      global.it = it;
    }
  }

  succeed(name, start) {
    assert(typeof name === 'string');
    assert(Number.isSafeInteger(start));

    const elapsed = Date.now() - start;

    let suffix = '';

    if (elapsed > this.mocha.slow)
      suffix = `\x1b[31m (${elapsed}ms)\x1b[m`;
    else if (elapsed > this.mocha.slow / 2)
      suffix = `\x1b[33m (${elapsed}ms)\x1b[m`;

    this.log(`  \x1b[32m\u2713\x1b[m \x1b[90m${name}\x1b[m${suffix}`);
    this.mocha.passing += 1;
  }

  fail(name, err) {
    assert(typeof name === 'string');

    const id = this.mocha.errors.length + 1;

    this.log(`  \x1b[31m${id}) ${name}\x1b[m `);
    this.mocha.errors.push([this.name, name, err]);
    this.mocha.failing += 1;

    return !this.mocha.bail;
  }

  async run() {
    if (this.tests.length === 0
        && this.suites.length === 0) {
      return true;
    }

    if (this.name) {
      this.log('');
      this.log(`${this.name}`);
    }

    for (const before of this.befores) {
      try {
        await this.runTest(before);
      } catch (e) {
        return this.fail('"before all" hook', e);
      }
    }

    for (const [name, func] of this.tests) {
      for (const before of this.beforeEaches) {
        try {
          await this.runTest(before);
        } catch (e) {
          return this.fail(`"before each" hook for "${name}"`, e);
        }
      }

      const start = Date.now();

      let failed, err;

      for (let i = 0; i < this.retries + 1; i++) {
        failed = false;

        try {
          await this.runTest(func);
        } catch (e) {
          failed = true;
          err = e;
        }

        if (!failed)
          break;
      }

      if (failed) {
        if (!this.fail(name, err))
          return false;
      } else {
        this.succeed(name, start);
      }

      for (const after of this.afterEaches) {
        try {
          await this.runTest(after);
        } catch (e) {
          return this.fail(`"after each" hook for "${name}"`, e);
        }
      }
    }

    for (const suite of this.suites) {
      if (!await suite.run())
        return false;
    }

    for (const after of this.afters) {
      try {
        await this.runTest(after);
      } catch (e) {
        return this.fail('"after all" hook', e);
      }
    }

    return true;
  }

  async runTest(func) {
    assert(typeof func === 'function');

    return new Promise((resolve, reject) => {
      const job = new Job(this, resolve, reject);

      if (func.length > 0) {
        const cb = err => job.callback(err);

        try {
          func.call(job.api, cb);
        } catch (e) {
          job.reject(e);
        }

        return;
      }

      let result;

      try {
        result = func.call(job.api);
      } catch (e) {
        job.reject(e);
        return;
      }

      if (!(result instanceof Promise)) {
        job.resolve();
        return;
      }

      result
        .then(_ => job.resolve())
        .catch(err => job.reject(err));
    });
  }

  static from(mocha, func) {
    return new this(mocha, mocha, '', func);
  }
}

/**
 * Job
 */

class Job {
  constructor(suite, resolve, reject) {
    assert(suite instanceof Suite);
    assert(typeof resolve === 'function');
    assert(typeof reject === 'function');

    this.timeouts = suite.timeouts;
    this.timer = null;
    this.called = false;
    this._resolve = resolve;
    this._reject = reject;

    this.api = {
      timeout: ms => this.timeout(ms)
    };

    this.timeout(suite.timeout);
  }

  resolve() {
    if (this.called)
      return;

    this.called = true;
    this.clear();
    this._resolve();
  }

  reject(err) {
    if (this.called)
      return;

    this.called = true;
    this.clear();
    this._reject(err);
  }

  callback(err) {
    if (err)
      this.reject(err);
    else
      this.resolve();
  }

  timeout(timeout) {
    timeout >>>= 0;

    if (!this.timeouts)
      return;

    if (this.called)
      return;

    this.clear();

    if (timeout !== 0) {
      this.timer = setTimeout(() => {
        this.reject(new Error(`Timeout of ${timeout}ms exceeded.`));
      }, timeout);
    }
  }

  clear() {
    if (this.timer != null) {
      clearTimeout(this.timer);
      this.timer = null;
    }
  }
}

/*
 * Helpers
 */

function indent(str, depth) {
  if (depth == null)
    depth = 0;

  assert(typeof str === 'string');
  assert((depth >>> 0) === depth);

  if (depth === 0)
    return str;

  let spaces = '';

  for (let i = 0; i < depth * 2; i++)
    spaces += ' ';

  return str.replace(/^/gm, spaces);
}

function formatStack(stack) {
  let str = String(stack);

  const index = str.indexOf('\n    at ');

  if (index !== -1)
    str = str.substring(index + 1);

  return str.replace(/^ +/gm, '');
}

function wrap(file) {
  assert(typeof file === 'string');

  return () => {
    const path = resolve(cwd, file);

    delete require.cache[path];

    try {
      require(path);
    } catch (e) {
      if (e.code === 'MODULE_NOT_FOUND')
        throw new Error(`Could not find ${file}.`);

      throw e;
    }
  };
}

function readdir(path) {
  assert(typeof path === 'string');
  return fs.readdirSync(path).map((name) => {
    return join(path, name);
  });
}

function exists(file) {
  assert(typeof file === 'string');
  try {
    fs.statSync(file);
    return true;
  } catch (e) {
    if (e.code !== 'ENOENT')
      throw e;
    return false;
  }
}

function flatten(files, recurse = false) {
  assert(Array.isArray(files));
  assert(typeof recurse === 'boolean');

  for (const file of files)
    assert(typeof file === 'string');

  const limit = recurse ? (-1 >>> 0) : 1;

  return walk(files, limit, []);
}

function walk(files, limit, out) {
  for (const file of files) {
    const stat = fs.statSync(file);

    if (stat.isDirectory()) {
      if (limit > 0)
        walk(readdir(file), limit - 1, out);
      continue;
    }

    const isJS = extname(file) === '.js';

    if (stat.isFile() && isJS) {
      out.push(file);
      continue;
    }
  }

  return out;
}

function exclude(files, excludes) {
  assert(Array.isArray(files));
  assert(excludes instanceof Set);

  return files.filter((file) => {
    const name = basename(file);
    return !excludes.has(name);
  });
}

/*
 * Main
 */

process.on('unhandledRejection', (err, promise) => {
  stderr.write('Unhandled rejection:\n');
  stderr.write('\n');
  if (err && err.stack)
    err = String(err.stack);
  stderr.write(err + '\n');
  exit(1);
});

(async () => {
  const mocha = new Mocha(stdout);
  const excludes = new Set();
  const fileArgs = [];
  const requires = [];

  let files = [];
  let sort = false;
  let doExit = false;
  let recurse = false;

  for (let i = 2; i < argv.length; i++) {
    const arg = argv[i];

    let next = '';

    if (i + 1 < argv.length)
      next = argv[i + 1];

    switch (arg) {
      case '-V':
      case '--version':
        stdout.write(VERSION + '\n');
        return;
      case '-c':
      case '--colors':
        mocha.colors = true;
        break;
      case '-C':
      case '--no-colors':
        mocha.colors = false;
        break;
      case '-O':
      case '--reporter-options':
        i += 1;
        break;
      case '-R':
      case '--reporter':
        if (next !== 'spec') {
          stderr.write(`Invalid reporter: ${next}.\n`);
          exit(1);
        }
        i += 1;
        break;
      case '-S':
      case '--sort':
        sort = true;
        break;
      case '-b':
      case '--bail':
        mocha.bail = true;
        break;
      case '-g':
      case '--grep':
        mocha.grep = new RegExp(next);
        i += 1;
        break;
      case '-f':
      case '--fgrep':
        mocha.fgrep = next;
        i += 1;
        break;
      case '-i':
      case '--invert':
        mocha.invert = true;
        break;
      case '-r':
      case '--require':
        if (exists(next) || exists(`${next}.js`))
          next = resolve(cwd, next);
        requires.push(next);
        i += 1;
        break;
      case '-s':
      case '--slow':
        mocha.slow = next >>> 0;
        i += 1;
        break;
      case '-t':
      case '--timeout':
        mocha.timeout = next >>> 0;
        i += 1;
        break;
      case '--no-timeouts':
        mocha.timeouts = false;
        break;
      case '--exit':
        doExit = true;
        break;
      case '--recursive':
        recurse = true;
        break;
      case '--retries':
        mocha.retries = next >>> 0;
        i += 1;
        break;
      case '--file':
        fileArgs.push(next);
        i += 1;
        break;
      case '--exclude':
        next = basename(next);
        excludes.add(next);
        i += 1;
        break;
      case '-h':
      case '--help':
        stdout.write(HELP);
        return;
      default:
        if (arg.length === 0 || arg[0] === '-') {
          stderr.write(`Invalid option: ${arg}.\n`);
          exit(1);
        }
        files.push(arg);
        break;
    }
  }

  if (files.length === 0) {
    if (exists('test'))
      files.push('test');
    else if (exists('test.js'))
      files.push('test.js');
  }

  files = fileArgs.concat(files);
  files = files.map(file => resolve(cwd, file));
  files = flatten(files, recurse);
  files = exclude(files, excludes);

  if (sort)
    files.sort();

  module.paths.push(cwd, join(cwd, 'node_modules'));

  for (const file of requires)
    require(file);

  const funcs = files.map(file => wrap(file));
  const code = await mocha.run(funcs);

  if (doExit) {
    exit(code);
    return;
  }

  process.on('exit', () => exit(code));
})().catch((err) => {
  stderr.write('An error occurred outside of the test suite:\n');
  stderr.write('\n');
  if (err && err.stack)
    err = String(err.stack);
  stderr.write(err + '\n');
  exit(1);
});
